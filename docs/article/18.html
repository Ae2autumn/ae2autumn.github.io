<!DOCTYPE html>
<html lang="zh-CN">

   <head>

      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>"æˆ‘" - ğ€ğğŸğšğ®ğ­ğ®ğ¦ğ§</title>
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
      <link rel="icon" href="https://avatars.githubusercontent.com/u/195545824?v=4">
      <!--
        FOUC é˜²é—ªä¿®å¤ï¼šåœ¨ä»»ä½•æ¸²æŸ“å‘ç”Ÿå‰ï¼Œæ£€æŸ¥ localStorage ä¸æœåŠ¡ç«¯ä¸»é¢˜æ˜¯å¦å†²çªã€‚
        ä¼˜å…ˆçº§ï¼šlocalStorage > æœåŠ¡ç«¯é…ç½®å€¼ã€‚
        è‹¥ä¸¤è€…ä¸åŒï¼Œæå‰æ³¨å…¥ä¸´æ—¶æ ·å¼è¦†ç›–èƒŒæ™¯è‰²/å­—è‰²ï¼Œé¿å…é¡µé¢åŠ è½½æ—¶çš„ä¸»é¢˜é—ªçƒã€‚
        applyTheme() æ‰§è¡Œå®Œæ¯•åä¼šç§»é™¤æ­¤ä¸´æ—¶æ ·å¼ã€‚
      -->
      <script>
        (function () {
          var saved      = localStorage.getItem('theme');
          var serverMode = "dark";
          // æ²¡æœ‰ localStorage å€¼ï¼Œç›´æ¥ç”¨æœåŠ¡ç«¯æ¸²æŸ“çš„ classï¼Œæ— éœ€ä»»ä½•å¹²é¢„
          if (!saved || saved === serverMode) return;
          var style = document.createElement('style');
          style.id  = 'theme-fouc-fix';
          style.textContent = saved === 'light'
            ? 'body { background-color: #fff    !important; color: #000 !important; }'
            : 'body { background-color: #121212 !important; color: #fff !important; }';
          document.head.appendChild(style);
        })();
      </script>
      <style>
         /* ==================== åŸºç¡€æ ·å¼ ==================== */
         *, *::before, *::after {
            box-sizing: border-box;
         }
   
         * {
            margin: 0;
            padding: 0;
         }
   
         body {
            background-color: #121212;
            color: #fff;
            font-family: Arial, sans-serif;
            line-height: 1.6;
            padding: 20px;
            max-width: 1000px;
            margin: 0 auto;
            position: relative;
            transition: background-color 0.5s ease, color 0.5s ease;
            overflow-x: hidden;
            word-wrap: break-word;
            word-break: break-word;
            overflow-wrap: break-word;
         }
   
         /* ==================== ä¸»é¢˜é¢œè‰²å˜é‡ ==================== */
         body.dark-mode {
            background-color: #121212;
            color: #ffffff;
            --reveal-hi:  255, 0, 0;
            --reveal-mid: 180, 30, 30;
         }
   
         body.light-mode {
            background-color: #fff;
            color: #000;
            --reveal-hi:  80, 80, 180;
            --reveal-mid: 60, 60, 160;
         }
   
         body.dark-mode .header { border-bottom-color: #333; }
         body.dark-mode .title { color: #fff; }
         body.dark-mode .summary { color: #ccc; }
         body.dark-mode .date { color: #999; }
         body.dark-mode .tag { background-color: #333; color: #fff; }
         body.dark-mode h1, body.dark-mode h2, body.dark-mode h3,
         body.dark-mode h4, body.dark-mode h5, body.dark-mode h6 {
            border-bottom-color: #333;
            color: #fff;
         }
         body.dark-mode .comments { border-top-color: #333; }
   
         body.light-mode .header { border-bottom-color: #ddd; }
         body.light-mode .title { color: #000; }
         body.light-mode .summary { color: #666; }
         body.light-mode .date { color: #777; }
         body.light-mode .tag { background-color: #eee; color: #000; }
         body.light-mode h1, body.light-mode h2, body.light-mode h3,
         body.light-mode h4, body.light-mode h5, body.light-mode h6 {
            border-bottom-color: #ddd;
            color: #000;
         }
         body.light-mode .comments { border-top-color: #ddd; }
   
         /* ==================== Reveal ::before å…¬å…±ç»“æ„ ==================== */
         .side-menu-wrapper::before,
         .menu-right::before,
         .floating-btn::before {
            content: '';
            position: absolute;
            inset: -1px;
            padding: 1px;
            -webkit-mask:
               linear-gradient(#fff 0 0) content-box,
               linear-gradient(#fff 0 0);
            -webkit-mask-composite: xor;
            mask-composite: exclude;
            pointer-events: none;
            z-index: 2;
         }
   
         /* ==================== æ–‡ç« å†…å®¹æ ·å¼ ==================== */
         .header {
            margin-bottom: 9px;
            padding: 20px;
            padding-bottom: 3px;
            border-bottom: 1px solid #333;
            transition: border-color 0.5s ease;
         }
   
         .title {
            font-size: 2.5rem;
            margin-bottom: 3px;
            color: #fff;
            transition: color 0.5s ease;
         }
   
         .summary {
            font-size: 1.1rem;
            margin-bottom: 3px;
            color: #ccc;
            transition: color 0.5s ease;
         }
   
         .date {
            color: #999;
            font-size: 0.9rem;
            margin-bottom: 3px;
            transition: color 0.5s ease;
         }
   
         .tags {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 3px;
         }
   
         .tag {
            background-color: #333;
            color: #fff;
            padding: 2px 10px;
            border-radius: 3px;
            font-size: 0.9rem;
            transition: background-color 0.5s ease, color 0.5s ease;
         }
   
         .content {
            padding: 20px;
            padding-top: 0px;
            margin-bottom: 50px;
            transition: color 0.5s ease;
            overflow-x: hidden;
         }
   
         /* ==================== Markdownå†…å®¹æ ·å¼ ==================== */
         .content p {
            margin-top: 0;
            margin-bottom: 0.3em;
            line-height: 1.5;
         }
   
         .content h1, .content h2, .content h3,
         .content h4, .content h5, .content h6 {
            margin: 1.5em 0 0.5em;
            padding-bottom: 10px;
            border-bottom: 1px solid #333;
            transition: border-color 0.5s ease, color 0.5s ease;
         }
   
         .content ul, .content ol {
            margin: 0.8em 0;
            padding-left: 2em;
         }
   
         .content li {
            margin: 0.3em 0;
            line-height: 1.6;
         }
   
         .content pre {
            margin: 1em 0;
            padding: 1em;
            background-color: #f5f5f5;
            border-radius: 4px;
            overflow-x: auto;
            white-space: pre;
            max-width: 100%;
         }
   
         body.dark-mode  .content pre { background-color: #2d2d2d; color: #f8f8f2; }
         body.light-mode .content pre { background-color: #f5f5f5; color: #333; }
   
         .content code {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.9em;
         }
   
         .content p code {
            background-color: #f5f5f5;
            padding: 0.2em 0.4em;
            border-radius: 3px;
         }
   
         body.dark-mode .content p code { background-color: #3a3a3a; color: #f8f8f2; }
   
         .content blockquote {
            margin: 1em 0;
            padding: 0.5em 1em;
            border-left: 4px solid #ddd;
            background-color: #f9f9f9;
            color: #666;
            border-radius: 5px;
         }
   
         body.dark-mode .content blockquote { border-left-color: #555; background-color: #2a2a2a; color: #ccc; }
   
         .table-wrapper { overflow-x: auto; margin: 20px 0; max-width: 100%; }
   
         .content table {
            margin: 1em 0;
            border-collapse: collapse;
            width: 100%;
            max-width: 100%;
         }
   
         .content th, .content td {
            border: 1px solid #ddd;
            padding: 0.5em 1em;
            text-align: left;
            max-width: 300px;
         }
   
         .content th { background-color: #f5f5f5; font-weight: 600; }
         body.dark-mode .content th { background-color: #333; border-color: #444; }
         body.dark-mode .content td { border-color: #444; }
   
         .content img { max-width: 100%; height: auto; margin: 1em 0; border-radius: 4px; display: block; }
         .content hr { margin: 2em 0; border: none; border-top: 1px solid #ddd; }
   
         .content a {
            color: #4da6ff;
            text-decoration: none;
            border-bottom: 1px dotted rgba(77, 166, 255, 0.5);
            transition: all 0.3s ease;
         }
   
         body.dark-mode .content a { color: #6bb8ff; border-bottom: 1px dotted rgba(107, 184, 255, 0.5); }
   
         .content a:hover {
            color: #fff;
            border-bottom: 1px solid rgba(77, 166, 255, 0.8);
            background-color: rgba(77, 166, 255, 0.1);
         }
   
         body.dark-mode .content a:hover {
            color: #fff;
            border-bottom: 1px solid rgba(107, 184, 255, 0.8);
            background-color: rgba(107, 184, 255, 0.1);
         }
   
         /* ==================== è¯„è®ºåŒº ==================== */
         .comments {
            margin-top: 50px;
            padding: 20px;
            border-top: 1px solid #333;
            transition: border-color 0.5s ease;
         }
   
         /* ==================== äºšå…‹åŠ›æµ®åŠ¨æŒ‰é’® ==================== */
         .floating-btn {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            font-size: 24px;
            z-index: 1000;
            border: 1px solid rgba(255, 255, 255, 0.12); /* ç§»åŠ¨ç«¯å¯è§ */
            outline: none;
            color: #fff;
            background: rgba(20, 20, 20, 0.55);
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            transition: background 0.3s ease, border-color 0.3s ease;
         }

         body.is-desktop .floating-btn {
            border: none;
         }

         body.light-mode .floating-btn {
            background: rgba(255, 255, 255, 0.55);
            border-color: rgba(0, 0, 0, 0.1);
            color: #000;
         }
   
         /* ==================== é®ç½© ==================== */
         .menu-mask {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(2px);
            -webkit-backdrop-filter: blur(2px);
            z-index: 998;
            display: none;
            transition: opacity 0.3s ease;
         }
         .menu-mask.active { display: block; }
   
         /* ==================== äºšå…‹åŠ›ä¾§è¾¹èœå• wrapper ==================== */
         .side-menu-wrapper {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 250px;
            height: 400px;
            max-width: calc(100vw - 60px);
            border-radius: 12px;
            z-index: 999;
            display: none;
            pointer-events: none;
         }
   
         .side-menu-wrapper.active {
            display: block;
            animation: menuAppear 0.3s cubic-bezier(0.68, -0.55, 0.27, 1.55);
         }
   
         @keyframes menuAppear {
            0%   { transform: scale(0.1); opacity: 0; }
            100% { transform: scale(1);   opacity: 1; }
         }
   
         /* Reveal è¾¹æ¡†å±‚ - ä»…æ¡Œé¢ç«¯æ˜¾ç¤º */
         .side-menu-wrapper::before {
            border-radius: inherit;
            background: radial-gradient(
               150px circle at var(--rx, -9999px) var(--ry, -9999px),
               rgba(var(--reveal-hi),  0.95),
               rgba(var(--reveal-mid), 0.45) 45%,
               transparent 70%
            );
            opacity: 0;
         }
   
         body.is-desktop .side-menu-wrapper::before {
            opacity: 1;
         }
   
         /* ==================== äºšå…‹åŠ›ä¾§è¾¹èœå• ==================== */
         .side-menu {
            position: relative;
            width: 100%;
            height: 100%;
            border-radius: 12px;
            display: none;
            flex-direction: row;
            overflow: hidden;
            /* background / backdrop-filter å·²ç§»è‡³äº”å±‚å­å…ƒç´ ï¼ˆè§ .menu-layer-*ï¼‰*/
            border: 1px solid rgba(255, 255, 255, 0.18);
            pointer-events: auto;
            isolation: isolate;         /* é˜²æ­¢å­å±‚ z-index æº¢å‡ºåˆ° wrapper å±‚ */
            transition: border-color 0.5s ease;
         }
   
         body.light-mode .side-menu {
            border-color: rgba(0, 0, 0, 0.12);
         }
   
         body.is-desktop .side-menu {
            border: none;
         }
   
         .side-menu.active {
            display: flex;
         }
   
         /* ==================== èœå•äº”å±‚æè´¨ç»“æ„ï¼ˆz-index 7-10ï¼Œç”± JS buildMenuLayers æ³¨å…¥ DOMï¼‰==================== */
         /* å„å±‚å¾®æ‰© inset:-1px è¦†ç›–å®¹å™¨è¾¹ç¼˜äºšåƒç´ ç¼éš™ï¼Œç”±çˆ¶çº§ overflow:hidden ç»Ÿä¸€è£å‰ªåœ†è§’ */
         .menu-layer-base,
         .menu-layer-light,
         .menu-layer-acrylic,
         .menu-layer-texture {
            position: absolute;
            inset: -1px;          /* æ¯”å®¹å™¨å¤š 1pxï¼Œæ¶ˆé™¤æ¨¡ç³Šå±‚è¾¹ç¼˜æ¸²æŸ“ç¼éš™ */
            pointer-events: none;
            /* ä¸è®¾ border-radiusï¼šç”± .side-menu çš„ overflow:hidden ç»Ÿä¸€è£å‰ª */
         }

         /* åº•å±‚ï¼ˆz-index:7ï¼‰ï¼šæœ€è½»äºšå…‹åŠ›åº•è¡¬ï¼Œäº‘æ¯è‰²çš„ä¸»è¦æ¥æº */
         .menu-layer-base {
            z-index: 7;
            background: rgba(255, 255, 255, 0.03);
            backdrop-filter: blur(3px);
            -webkit-backdrop-filter: blur(3px);
         }
         body.light-mode .menu-layer-base {
            background: rgba(0, 0, 0, 0.03);
         }

         /* ç¬¬4å±‚ï¼ˆz-index:8ï¼‰ï¼šå†…éƒ¨ä½“ç§¯å…‰ï¼Œè·Ÿéšé¼ æ ‡ï¼ˆå¤ç”¨çˆ¶çº§ --rx/ry å˜é‡ï¼Œæ— éœ€æ–°å¢äº‹ä»¶ç›‘å¬ï¼‰
            ä¸æŒ‡å®šåœ†åŠå¾„ â†’ æµè§ˆå™¨ä»¥ farthest-corner ä¸ºå‡†ï¼Œè‡ªç„¶è¡°å‡æ— ç¡¬è¾¹ç•Œ */
         .menu-layer-light {
            z-index: 8;
            background: radial-gradient(
               circle at var(--rx, -9999px) var(--ry, -9999px),
               rgba(var(--reveal-hi,  255, 0, 0), 0.09)  0%,
               rgba(var(--reveal-mid, 180, 30, 30), 0.04) 40%,
               transparent 70%
            );
         }

         /* ç¬¬3å±‚ï¼ˆz-index:9ï¼‰ï¼šè¿‡æ¸¡å±‚ï¼ŒæŸ”åŒ–å…‰ç…§å…‰ä¸è¾¹æ¡†å…‰ä¹‹é—´çš„è¾¹ç•Œ */
         .menu-layer-acrylic {
            z-index: 9;
            background: rgba(255, 255, 255, 0.07);
            backdrop-filter: blur(10px) saturate(140%);
            -webkit-backdrop-filter: blur(10px) saturate(140%);
            opacity: 0.5;
         }
         body.light-mode .menu-layer-acrylic {
            background: rgba(0, 0, 0, 0.05);
         }

         /* ç¬¬2å±‚ï¼ˆz-index:10ï¼‰ï¼šæ–‘é©³è´¨æ„Ÿé¢„ç•™æ§½ï¼Œæš‚æ— å†…å®¹ */
         .menu-layer-texture {
            z-index: 10;
         }

         /* ==================== èœå•å·¦ä¾§ï¼šç« èŠ‚åˆ—è¡¨ ==================== */
         .menu-left {
            position: relative;
            z-index: 11;            /* è¦†ç›–åœ¨ .menu-layer-* (z-index 7-10) ä¹‹ä¸Š */
            width: 200px;
            padding: 20px;
            overflow-y: auto;
            scrollbar-width: none;
            background: transparent;
         }
   
         .menu-left::-webkit-scrollbar { display: none; }
   

         /* Canvas å åŠ å±‚ */
         #menuRevealCanvas {
            position: fixed;
            pointer-events: none;
            z-index: 1001;
            opacity: 0;
            transition: opacity 0.2s;
         }
         #menuRevealCanvas.active { opacity: 1; }
   
         /* ==================== ç« èŠ‚é¡¹ ==================== */
         .chapter-item {
            display: flex;
            align-items: center;
            padding: 10px 0;
            cursor: pointer;
            color: rgba(255, 255, 255, 0.7);
            transition: color 0.2s, padding-left 0.2s;
            position: relative;
         }
   
         .chapter-item::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 7px;
            right: 7px;
            height: 1px;
            transform: scaleY(0.5);
            transform-origin: bottom;
            background: rgba(255, 255, 255, 0.05);
            transition: opacity 0.3s;
         }
   
         body.light-mode .chapter-item::after {
            background: rgba(0, 0, 0, 0.3);
         }
   
         body.is-desktop .chapter-item::after {
            opacity: 0;
         }
   
         .chapter-item:last-child::after { display: none; }
   
         .chapter-item.h1-item { padding-left: 0; }
         .chapter-item.h2-item { padding-left: 14px; color: rgba(255,255,255,0.45); font-size: 0.9em; }
         .chapter-item.h3-item { padding-left: 28px; color: rgba(255,255,255,0.3);  font-size: 0.85em; }
   
         body.light-mode .chapter-item { color: rgba(0,0,0,0.7); }
         body.light-mode .chapter-item.h2-item { color: rgba(0,0,0,0.45); }
         body.light-mode .chapter-item.h3-item { color: rgba(0,0,0,0.3); }
   
         body.is-desktop .chapter-item:hover { color: #f00; }
         body.is-desktop .chapter-item.h1-item:hover { padding-left: 5px; }
         body.is-desktop .chapter-item.h2-item:hover { padding-left: 19px; }
         body.is-desktop .chapter-item.h3-item:hover { padding-left: 33px; }
   
         .chapter-item.current { color: red !important; }
         .chapter-item.hovered { color: red !important; }
   
         /* ==================== èœå•å³ä¾§ï¼šæŒ‰é’®åŒº ==================== */
         .menu-right {
            position: relative;
            z-index: 11;            /* åŒä¸Šï¼Œè¦†ç›–åœ¨ .menu-layer-* ä¹‹ä¸Š */
            width: 50px;
            height: 100%;
            display: flex;
            flex-direction: column;
            background: rgba(0, 0, 0, 0.2);
            border-left: 1px solid rgba(255, 255, 255, 0.15);
            transition: background 0.5s ease, border-color 0.5s ease;
         }
   
         body.light-mode .menu-right {
            background: rgba(0, 0, 0, 0.05);
            border-left-color: rgba(0, 0, 0, 0.1);
         }
   
         body.is-desktop .menu-right,
         body.is-desktop.light-mode .menu-right {
            border-left-color: transparent;
         }
   
         /* Reveal è¾¹æ¡†é»˜è®¤éšè—ï¼Œç§»åŠ¨ç«¯ä¸æ˜¾ç¤º */
         .menu-right::before {
            opacity: 0;
         }

         body.is-desktop .menu-right::before {
            opacity: 1;
            border-radius: 0 12px 12px 0;
            background: radial-gradient(
               130px circle at var(--rx, -9999px) var(--ry, -9999px),
               rgba(var(--reveal-hi),  0.7),
               rgba(var(--reveal-mid), 0.3) 45%,
               transparent 70%
            );
         }
   

         .menu-buttons {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            padding: 20px 0;
            width: 100%;
         }
   
         .menu-btn {
            color: rgba(255, 255, 255, 0.75);
            background: none;
            border: none;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 20px;
            width: 50px;
            height: 47px;
            text-align: center;
            border-radius: 0;
            display: flex;
            justify-content: center;
            align-items: center;
         }
   
         body.light-mode .menu-btn { color: rgba(0, 0, 0, 0.6); }
         body.is-desktop .menu-btn:hover { color: #f00; background-color: rgba(255, 0, 0, 0.1); }
   
         .close-btn {
            position: relative;
            height: 50px;
            background: rgba(0, 0, 0, 0.15);
            color: rgba(255, 255, 255, 0.6);
            border: none;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            cursor: pointer;
            font-size: 16px;
            transition: background 0.2s, color 0.2s, border-color 0.2s;
            width: 100%;
         }
   
         body.light-mode .close-btn {
            background: rgba(0, 0, 0, 0.04);
            color: rgba(0, 0, 0, 0.5);
            border-top-color: rgba(0, 0, 0, 0.08);
         }
   
         body.is-desktop .close-btn {
            border-top: none;
            background: transparent;
         }
   
         body.is-desktop .close-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: radial-gradient(
               130px circle at var(--rx, -9999px) var(--ry, -9999px),
               rgba(var(--reveal-hi),  0.95),
               rgba(var(--reveal-mid), 0.4) 45%,
               transparent 70%
            );
            pointer-events: none;
            z-index: 3;
         }
   
         body.is-desktop .close-btn:hover { color: #f00; background-color: rgba(255, 0, 0, 0.08); }
   
         /* ==================== Revealï¼šfloating-btn ==================== */
         /* --toggle-hi / --toggle-mid ç”± JS updateProgress éšæ»šåŠ¨è¿›åº¦å®æ—¶å†™å…¥ bodyï¼Œ
            é»˜è®¤å€¼å¯¹åº”åˆå§‹çŠ¶æ€ï¼ˆæš—è‰²ä¸»é¢˜ã€è¿›åº¦ä¸º 0ï¼‰ã€‚                              */
         .floating-btn::before {
            border-radius: 50%;
            background: radial-gradient(
               80px circle at var(--rx, -9999px) var(--ry, -9999px),
               rgba(var(--toggle-hi,  255, 0,   0),   0.95),
               rgba(var(--toggle-mid, 180, 30,  30),  0.45) 45%,
               transparent 70%
            );
         }

         /* ==================== floating-btn æ‚¬åœå‘å…‰ï¼ˆM2 ç§»é™¤ boxShadow='none' åç”Ÿæ•ˆï¼‰==================== */
         body.is-desktop .floating-btn:hover {
            /* --toggle-glow ç”± JS updateProgress é¢„æ„å»ºå®Œæ•´ rgba() å­—ç¬¦ä¸²å†™å…¥ï¼Œé¿å… rgba(var(), alpha) è§£ææ­§ä¹‰ */
            box-shadow: 0 0 20px 6px var(--toggle-glow, rgba(255, 0, 0, 0.45)),
                        0 6px 24px rgba(0, 0, 0, 0.45);
            transition: box-shadow 0.25s ease;
         }

         /* ==================== èœå•å®¹å™¨é˜´å½± ==================== */
         .side-menu-wrapper {
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.55), 0 2px 8px rgba(0, 0, 0, 0.28);
         }
   
         .header, .floating-btn, .side-menu, .comments {
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
         }
         
      </style>

   </head>

   <body class="dark-mode">
      <div class="header">
         <h1 class="title">"æˆ‘"</h1>
         <p class="summary">æš‚æ— ç®€ä»‹</p>
         <div class="date">2026-02-24</div>
         <div class="tags">
            <span class="tag">è®°å½•</span>
            <span class="tag">å›å¿†</span>
         </div>
      </div>
   
      <div class="content">
         <p>æˆ‘çœŸçš„æœ‰åœ¨å˜,ä¸€ç›´åœ¨å˜<br>
ä¸åƒæ˜¯é‚£ç§çªç„¶çš„,ä¸€ç¬é—´çš„.è€Œæ˜¯ä½ èƒ½å¤Ÿæ„Ÿè§‰åˆ°,æ…¢æ…¢çš„,æ…¢æ…¢çš„.å¾ˆå¤šä¸œè¥¿éƒ½å˜äº†<br>
æ¸æ¸çš„,æˆ‘ä¹Ÿæ·¡æ¼ äº†<br>
æˆ‘æ›¾å¥½åƒå¾ˆå¤©çœŸ,æˆ‘è¿‡å»ä¼¼ä¹ä»€ä¹ˆéƒ½ç›¸ä¿¡,ä»€ä¹ˆéƒ½å¸Œå†€<br>
ç°åœ¨ä¸æ˜¯äº†...</p>
<p>ç›´åˆ°å‡ å¤©å‰å»å¤–å©†å®¶,å¥¹ä»¬åˆæèµ·äº†ä¸€äº›å¾€äº‹.é—®æˆ‘,ç„¶è€Œæˆ‘å´ä»€ä¹ˆä¹Ÿæƒ³ä¸èµ·æ¥<br>
æˆ‘æ˜¯çœŸçš„ä¸è®°å¾—äº†...ä»€ä¹ˆéƒ½è®°ä¸èµ·æ¥</p>
<p>æ®è¯´,äººåœ¨å—åˆ°é‡å¤§æ‰“å‡»çš„æ—¶å€™.å¤§è„‘ä¼šé€‰æ‹©æ€§çš„å¤±å¿†æ¥ä¿æŠ¤ä½ ,æˆ‘åƒæ˜¯è¿™æ ·çš„å—?æˆ‘ä¼¼ä¹ä»€ä¹ˆä¹Ÿä¸åœ¨æ„,ç„¶è€Œå¥½åƒåˆåœ¨æ„ä¸€åˆ‡</p>
<p>"è´Ÿè´£"<br>
Duty,æˆ‘æ²‰é»˜äº†.åŸæ¥æ˜¯å› ä¸ºè´Ÿè´£,ä¹Ÿå°±åƒä½ åœ¨å¯¹ç€ç©ºè°·å˜¶å¼,å´æœŸç›¼ç€èƒ½å¤Ÿå¬åˆ°å›å“<br>
......<br>
ä¸è¿‡èƒ½å¤Ÿè¯´ä»€ä¹ˆå‘¢?è‡³å°‘èƒ½å¤Ÿè¯æ˜ABCæ˜¯ä¸€ä¸ªè´Ÿè´£ä»»çš„äºº,è‡³å°‘èƒ½å¤Ÿè¯´æ˜,ABCå¾ˆæœ‰è´£ä»»å¿ƒ<br>
......</p>
<p>æˆ‘åˆæƒ³åˆ°æˆ‘äº†<br>
æˆ‘æƒ³åˆ°äº†æˆå¹´,æˆ‘æƒ³åˆ°äº†ä¸€ç¾¤äººåœ¨ç¬‘,æˆ‘æƒ³åˆ°äº†"æˆäººç¤¼",æˆ‘æƒ³åˆ°äº†"å­˜åœ¨",æˆ‘æƒ³åˆ°äº†"å®¶äºº",æˆ‘æƒ³åˆ°äº†"Friends"<br>
......<br>
ä¸è¿‡å¥½åƒæ¯ä¸€ä»¶éƒ½ä¸æˆ‘æ¯«æ— å…³ç³»,æˆ‘çªç„¶åˆå¤±è½äº†èµ·æ¥,è¿™æ˜¯å¤±è½å—?å¦‚æœèƒ½å¤Ÿç§°ä¹‹ä¸º"æ˜¯"çš„è¯<br>
æˆ‘åˆå“­äº†...<br>
ä¸è¿‡å€’æ²¡æœ‰çœŸçš„å“­,æˆ‘çš„è„‘å­å·²ç»å“­å®Œäº†.ä½†æ˜¯æˆ‘çš„Bodyè¡¨ç¤ºä¸åƒè¿™ä¸€å¥—,æ²¡åŠæ³•,å°±å¥½åƒè‡ªå·±ç²¾ç¥åˆ†è£‚äº†ä¸€æ ·,åŠæˆªæ˜¯åŠæˆª</p>
<p>?</p>
      </div>
   
      <div class="comments"></div>
   
      <button class="floating-btn" id="menuToggle">â˜°</button>
   
      <div class="menu-mask" id="menuMask"></div>
   
      <div class="side-menu-wrapper" id="sideMenuWrapper">
         <div class="side-menu" id="sideMenu">
            <div class="menu-left" id="chapterList"></div>
            <div class="menu-right" id="menuRightEl">
               <div class="menu-buttons">
                  <button class="menu-btn" id="toBottomBtn">â–¼</button>
                  <button class="menu-btn" id="middleBtn">â—</button>
                  <button class="menu-btn" id="toTopBtn">â–²</button>
               </div>
               <button class="close-btn" id="closeBtn">â•³</button>
            </div>
         </div>
      </div>
   
      <canvas id="menuRevealCanvas"></canvas>
   
      <script>
        // ==================== 1. å·¥å…·å‡½æ•° ====================

        /**
         * é€šç”¨é˜²æŠ–å‡½æ•°
         * è¿”å›å¯¹è±¡è€Œéå‡½æ•°ï¼Œæ–¹ä¾¿åœ¨éœ€è¦æ—¶ç²¾ç¡® cancelã€‚
         */
        function createDebounce(fn, delay) {
          let timer = null;
          return {
            call(...args) {
              clearTimeout(timer);
              timer = setTimeout(() => { timer = null; fn(...args); }, delay);
            },
            cancel() { clearTimeout(timer); timer = null; },
            get pending() { return timer !== null; }
          };
        }

        /**
         * åŸºäº Promise çš„ smooth scroll å®Œæˆæ£€æµ‹ã€‚
         * è½®è¯¢ä½ç½®å˜åŒ–åˆ¤æ–­æ»šåŠ¨ç»“æŸï¼Œé¿å…ç¡¬ç¼–ç è¶…æ—¶çš„ç«æ€ã€‚
         */
        function smoothScrollPromise(scrollFn, getPosition, timeout = 1000) {
          return new Promise(resolve => {
            scrollFn();
            let lastPos  = getPosition();
            let stable   = 0;
            let stableAt = null;  // é¦–æ¬¡ç¨³å®šå¸§çš„æ—¶é—´æˆ³ï¼Œç”¨äºä¿è¯æœ€çŸ­ç¨³å®šæ—¶é•¿
            let started  = false;
            const t0 = performance.now();

            function check() {
              const now = performance.now();
              const pos = getPosition();
              if (pos !== lastPos) {
                started = true; stable = 0; stableAt = null; lastPos = pos;
              } else {
                if (started) {
                  if (stableAt === null) stableAt = now;
                  // è‡³å°‘ 3 å¸§ + è·é¦–æ¬¡ç¨³å®šå¸§ â‰¥ 50msï¼Œé¿å…é«˜å¸§ç‡è®¾å¤‡è¿‡æ—©åˆ¤å®šç»“æŸ
                  if (++stable >= 3 && now - stableAt >= 50) { resolve(); return; }
                }
                else if (now - t0 > 300) { resolve(); return; }
              }
              if (now - t0 > timeout) { resolve(); return; }
              requestAnimationFrame(check);
            }
            requestAnimationFrame(check);
          });
        }

        /**
         * ç‚¹åˆ°çŸ©å½¢çš„è·ç¦»ï¼ˆç‚¹åœ¨çŸ©å½¢å†…æ—¶ä¸º 0ï¼‰ã€‚
         * æ‰€æœ‰ Reveal å…ƒç´ çš„è·ç¦»åˆ¤æ–­å…±ç”¨è¿™ä¸€ä¸ªå‡½æ•°ã€‚
         */
        function distToRect(mouseX, mouseY, rect) {
          const dx = Math.max(rect.left - mouseX, 0, mouseX - rect.right);
          const dy = Math.max(rect.top  - mouseY, 0, mouseY - rect.bottom);
          return Math.sqrt(dx * dx + dy * dy);
        }

        /**
         * ç‚¹åˆ°çŸ©å½¢é¡¶è¾¹çš„è·ç¦»ï¼ˆcloseBtn ä¸“ç”¨ï¼šåªæ„Ÿåº”é¡¶è¾¹ï¼‰ã€‚
         */
        function distToTopEdge(mouseX, mouseY, rect) {
          const dx = Math.max(rect.left - mouseX, 0, mouseX - rect.right);
          const dy = Math.abs(mouseY - rect.top);
          return Math.sqrt(dx * dx + dy * dy);
        }

        /** æ›´æ–°å•ä¸ª Reveal å…ƒç´ çš„ CSS å˜é‡ã€‚rect å¯ç”±å¤–éƒ¨ä¼ å…¥ä»¥å¤ç”¨ç¼“å­˜ï¼Œçœå» reflowã€‚ */
        function updateRevealVar(el, mouseX, mouseY, range, distFn = distToRect, rect = null) {
          if (!el) return;
          const r    = rect || el.getBoundingClientRect();
          const dist = distFn(mouseX, mouseY, r);
          if (dist <= range) {
            el.style.setProperty('--rx', (mouseX - r.left) + 'px');
            el.style.setProperty('--ry', (mouseY - r.top)  + 'px');
          } else {
            el.style.setProperty('--rx', '-9999px');
            el.style.setProperty('--ry', '-9999px');
          }
        }

        /** æ¸…é™¤å•ä¸ªå…ƒç´ çš„ Reveal å˜é‡ã€‚ */
        function clearRevealVar(el) {
          if (!el) return;
          el.style.setProperty('--rx', '-9999px');
          el.style.setProperty('--ry', '-9999px');
        }


        // ==================== 2. DOM å¼•ç”¨ ====================
        const menuToggle      = document.getElementById('menuToggle');
        const sideMenuWrapper = document.getElementById('sideMenuWrapper');
        const sideMenu        = document.getElementById('sideMenu');
        const menuMask        = document.getElementById('menuMask');
        const closeBtn        = document.getElementById('closeBtn');
        const toBottomBtn     = document.getElementById('toBottomBtn');
        const middleBtn       = document.getElementById('middleBtn');
        const toTopBtn        = document.getElementById('toTopBtn');
        const chapterList     = document.getElementById('chapterList');
        const menuRightEl     = document.getElementById('menuRightEl');


        // ==================== 3. æ¡Œé¢/ç§»åŠ¨ç«¯æ£€æµ‹ ====================
        const isDesktop = window.matchMedia('(hover: hover) and (pointer: fine)').matches;
        if (isDesktop) {
          document.body.classList.add('is-desktop');
        } else {
          // ç§»åŠ¨ç«¯å®Œå…¨ä¸ä½¿ç”¨ Canvasï¼Œç›´æ¥ä» DOM ç§»é™¤ä»¥é‡Šæ”¾å†…å­˜
          const _mobileCanvas = document.getElementById('menuRevealCanvas');
          if (_mobileCanvas) _mobileCanvas.remove();
        }


        // ==================== 4. å…±äº«çŠ¶æ€å¯¹è±¡ ====================
        // æ‰€æœ‰è·¨æ¨¡å—å…±äº«çš„å¯å˜çŠ¶æ€ç»Ÿä¸€æ”¾åœ¨è¿™é‡Œï¼Œè¯»å†™éƒ½é€šè¿‡ state è¿›è¡Œã€‚
        const state = {
          currentId:               null,    // å½“å‰é«˜äº®çš„ heading id
          hoveredItem:             null,     // æ­£åœ¨æ‚¬åœçš„ chapter-item å…ƒç´ 
          activeState:             'scroll', // çŠ¶æ€æœºï¼š'scroll' | 'hover' | 'menu'
          isMenuScrolling:         false,
          isWheelScrolling:        false,
          isHoverScrolling:        false,
          programmaticScrollCount: 0,        // ç¨‹åºé©±åŠ¨çš„èœå•æ»šåŠ¨è®¡æ•°
          menuDrivingArticleCount: 0,        // èœå•é©±åŠ¨çš„æ–‡ç« æ»šåŠ¨è®¡æ•°
          lastMouseX:              -9999,    // æœ€æ–°é¼ æ ‡ä½ç½®ï¼ˆReveal å†™ï¼ŒHighlighter è¯»ï¼‰
          lastMouseY:              -9999,
        };


        // ==================== 5. ä¸»é¢˜ ====================
        // é¢œè‰²ç”± CSS ç»§æ‰¿æ§åˆ¶ï¼ˆbody.dark-mode color/#fffï¼Œbody.light-mode .floating-btn color/#000ï¼‰ï¼Œ
        // æ­¤å¤„æ— éœ€å†é€šè¿‡ JS è®¾ç½® menuToggle é¢œè‰²ã€‚
        // _isLightModeï¼šæ¨¡å—çº§ç¼“å­˜ï¼Œä»…åœ¨ applyTheme æ—¶æ›´æ–°ï¼Œé¿å… updateProgress æ¯æ¬¡æ»šåŠ¨è¯»å– classList
        let _isLightMode = false;

        function applyTheme() {
          const savedTheme  = localStorage.getItem('theme');
          const configTheme = "dark";
          const mode        = savedTheme || configTheme;
          _isLightMode = (mode === 'light');
          document.body.classList.toggle('light-mode', _isLightMode);
          document.body.classList.toggle('dark-mode',  !_isLightMode);
          // ç§»é™¤ <head> é‡Œæ³¨å…¥çš„ä¸´æ—¶é˜²é—ªæ ·å¼ï¼ˆè‹¥å­˜åœ¨ï¼‰
          const fouc = document.getElementById('theme-fouc-fix');
          if (fouc) fouc.remove();
        }
        applyTheme();


        // ==================== 6. ç« èŠ‚é«˜äº®å™¨ ====================

        /**
         * èœå•é©±åŠ¨æ–‡ç« æ»šåŠ¨çš„å…¬å…±è·¯å¾„ï¼š
         *   - ç»´æŠ¤ menuDrivingArticleCountï¼Œé˜²æ­¢æ»šåŠ¨æœŸé—´ updateActiveHeading å¹²æ‰°é«˜äº®
         *   - æ»šåŠ¨ç»“æŸåè°ƒç”¨ onFinally(scrolled: boolean) ä»¥ä¾¿è°ƒç”¨æ–¹ç»§ç»­çŠ¶æ€æœºæµè½¬
         * @param {string}   id        ç›®æ ‡ heading çš„ id
         * @param {function} onFinally (scrolled: boolean) => voidï¼Œåœ¨ finally å—ä¸­è°ƒç”¨
         */
        function driveArticleScroll(id, onFinally) {
          const heading = document.getElementById(id);
          if (!heading) { onFinally(false); return; }
          state.menuDrivingArticleCount++;
          smoothScrollPromise(
            () => heading.scrollIntoView({ behavior: 'smooth', block: 'start' }),
            () => window.scrollY
          ).finally(() => {
            state.menuDrivingArticleCount--;
            onFinally(true);
          });
        }


        /**
         * å°è£…äº†"ç« èŠ‚ item æ„å»º + é«˜äº®çŠ¶æ€æœº"çš„å…¨éƒ¨é€»è¾‘ã€‚
         * å¯¹å¤–æš´éœ²ä¸‰ä¸ªæ¥å£ï¼š
         *   init(onItemClick)  - æ„å»º DOMã€ç»‘å®šäº‹ä»¶ï¼Œä¼ å…¥ç‚¹å‡» item åçš„å›è°ƒ
         *   syncToMenu()       - èœå•æ‰“å¼€æ—¶è°ƒç”¨ï¼Œå°†å½“å‰é«˜äº®é¡¹å³æ—¶å±…ä¸­
         *   cancelHover()      - èœå•å…³é—­æ—¶è°ƒç”¨ï¼Œå–æ¶ˆæ‚¬åœçŠ¶æ€å¹¶å›é€€åˆ° scroll
         */
        function createChapterHighlighter({ contentEl, chapterListEl, isDesktop, state }) {

          const hoverScrollDebounce = createDebounce(onHoverScrollDebounced, 1500);
          const menuScrollDebounce  = createDebounce(onMenuScrollDebounced,  400);

          let allHeadings = [];
          // ç¼“å­˜å½“å‰æŒæœ‰ .current / .hovered çš„ DOM å…ƒç´ ï¼Œé¿å…æ¯æ¬¡ setHighlight è°ƒç”¨ querySelectorAll
          let _currentHighlightEl = null;

          // ä¸»åŠ¨æŸ¥è¯¢å½“å‰é¼ æ ‡ä½ç½®ä¸‹æ˜¯å¦æœ‰ chapter-itemï¼ˆä¸ä¾èµ–æµè§ˆå™¨è¡¥å‘çš„ pointer äº‹ä»¶ï¼‰
          function getItemAtPointer() {
            const el = document.elementFromPoint(state.lastMouseX, state.lastMouseY);
            return el ? el.closest('.chapter-item') : null;
          }

          // å”¯ä¸€é«˜äº®å…¥å£ï¼šç›´æ¥æ“ä½œç¼“å­˜å¼•ç”¨ï¼Œé¿å…å…¨é‡ querySelectorAll
          function setHighlight(id) {
            if (_currentHighlightEl) {
              _currentHighlightEl.classList.remove('current', 'hovered');
              _currentHighlightEl = null;
            }
            if (!id) return;
            const item = chapterListEl.querySelector(`.chapter-item[data-id="${id}"]`);
            if (item) {
              item.classList.add(state.activeState === 'scroll' ? 'current' : 'hovered');
              _currentHighlightEl = item;
            }
          }

          // æ»šåŠ¨èœå•è®©æŒ‡å®š item å±…ä¸­ï¼ˆè¿”å› Promiseï¼Œé¿å…ç¡¬ç¼–ç è¶…æ—¶ï¼‰
          function scrollMenuToItem(id, behavior = 'smooth') {
            const item = chapterListEl.querySelector(`.chapter-item[data-id="${id}"]`);
            if (!item) return Promise.resolve();
            const target = item.offsetTop - (chapterListEl.clientHeight - item.offsetHeight) / 2;
            if (chapterListEl.scrollHeight <= chapterListEl.clientHeight) return Promise.resolve();

            state.programmaticScrollCount++;
            return smoothScrollPromise(
              () => chapterListEl.scrollTo({ top: Math.max(0, target), behavior }),
              () => chapterListEl.scrollTop
            ).finally(() => { state.programmaticScrollCount--; });
          }

          // æ‰¾åˆ°å½“å‰èœå•å¯è§†åŒºä¸­å¿ƒæœ€è¿‘çš„ item
          function getCenteredItemId() {
            const items      = chapterListEl.querySelectorAll('.chapter-item');
            const containerR = chapterListEl.getBoundingClientRect();
            const centerY    = containerR.top + containerR.height / 2;
            let best = null, bestDist = Infinity;
            items.forEach(item => {
              const r    = item.getBoundingClientRect();
              const dist = Math.abs(r.top + r.height / 2 - centerY);
              if (dist < bestDist) { bestDist = dist; best = item; }
            });
            return best ? best.dataset.id : null;
          }

          // --- çŠ¶æ€ï¼šscroll ---

          // èœå•ä½ç½®è·Ÿéšç”¨ debounceï¼šé«˜äº®å®æ—¶æ›´æ–°ï¼Œèœå•åªåœ¨æ»šåŠ¨åœæ­¢åæ‰è·Ÿéšã€‚
          // é¿å…å¿«é€Ÿæ»šåŠ¨æ—¶å¤šä¸ªå¹¶å‘ smooth scroll äº’ç›¸æ‰“æ¶é€ æˆé—ªçƒã€‚
          const menuSyncDebounce = createDebounce((id) => {
            if (state.activeState === 'scroll' && !state.isMenuScrolling) {
              scrollMenuToItem(id);
            }
          }, 150);

          function applyScrollState(id) {
            if (state.activeState === 'hover' || state.activeState === 'menu') return;
            state.activeState = 'scroll';
            state.currentId   = id;
            setHighlight(id);           // é«˜äº®å®æ—¶åŒæ­¥
            menuSyncDebounce.call(id);  // èœå•ä½ç½® debounceï¼Œæ»šåŠ¨åœæ­¢åè·Ÿéš
          }

          function updateActiveHeading() {
            if (allHeadings.length === 0) return;
            if (state.menuDrivingArticleCount > 0) return;
            if (state.isHoverScrolling) return;
            const scrollY = window.scrollY;
            const offset  = 80;
            let current   = allHeadings[0];
            for (let i = 0; i < allHeadings.length; i++) {
              const top = allHeadings[i].getBoundingClientRect().top + scrollY;
              if (top <= scrollY + offset) current = allHeadings[i];
              else break;
            }
            if (current.id !== state.currentId || state.activeState !== 'scroll') {
              applyScrollState(current.id);
            }
          }

          // --- çŠ¶æ€ï¼šhover ---
          /**
           * DOM ä½ç§»åä¸»åŠ¨æ¨è¿›çŠ¶æ€æœºï¼Œä¸ä¾èµ–æµè§ˆå™¨è¡¥å‘çš„ pointer äº‹ä»¶ï¼ˆæ—¶åºä¸å¯é ï¼‰ã€‚
           */
          function resolvePointerAfterScroll(item) {
            const itemAtPointer = getItemAtPointer();
            if (itemAtPointer && itemAtPointer !== item) {
              onItemPointerEnter(itemAtPointer);      // ç§»äº¤ç»™æ–° itemï¼Œé‡å¯é“¾
            } else if (!itemAtPointer) {
              state.hoveredItem = null;
              state.activeState = 'scroll';
              setHighlight(state.currentId);          // é¼ æ ‡å·²ç¦»å¼€èœå•
            } else {
              hoverScrollDebounce.call(item);         // ä»åœ¨åŒä¸€ itemï¼Œé‡å¯é˜²æŠ–
            }
          }

          function onHoverScrollDebounced(item) {
            if (state.activeState !== 'hover' || state.hoveredItem !== item) return;
            setHighlight(item.dataset.id);

            // å…ˆå±…ä¸­èœå•ï¼Œå†è·³æ–‡ç« ï¼Œé¿å…ä¸¤ä¸ª smoothScrollPromise å¹¶å‘ç«äº‰
            state.isHoverScrolling = true;
            scrollMenuToItem(item.dataset.id).then(() => {
              state.isHoverScrolling = false;

              // å±…ä¸­åæ ¡éªŒçŠ¶æ€ï¼šå¤–éƒ¨ä¸­æ–­ä¼šç›´æ¥ä¿®æ”¹ stateï¼Œè¿™é‡Œåªéœ€è¯»å–å³å¯
              if (state.activeState !== 'hover' || state.hoveredItem !== item) return;

              state.isHoverScrolling = true;
              driveArticleScroll(item.dataset.id, () => {
                // currentId å…ˆäº isHoverScrolling æ›´æ–°ï¼Œé˜²æ­¢ onItemPointerLeave è¯»åˆ°æ—§å€¼
                if (state.activeState === 'hover' && state.hoveredItem === item) {
                  state.currentId = item.dataset.id;
                }
                state.isHoverScrolling = false;
                if (state.activeState === 'hover' && state.hoveredItem === item) {
                  resolvePointerAfterScroll(item);
                }
              });
            });
          }

          function onItemPointerEnter(item) {
            if (state.isWheelScrolling || state.isHoverScrolling) return;
            state.hoveredItem = item;
            state.activeState = 'hover';
            setHighlight(item.dataset.id);
            hoverScrollDebounce.call(item);
          }

          function onItemPointerLeave() {
            if (state.isWheelScrolling || state.isHoverScrolling) return;
            hoverScrollDebounce.cancel();
            state.hoveredItem = null;
            state.activeState = 'scroll';
            setHighlight(state.currentId);
            scrollMenuToItem(state.currentId);
          }

          // --- çŠ¶æ€ï¼šmenu ---
          function onMenuScrollDebounced() {
            state.isMenuScrolling = false;
            const centerId = getCenteredItemId();
            if (!centerId) { state.isWheelScrolling = false; return; }

            scrollMenuToItem(centerId).then(() => {
              if (state.activeState !== 'menu' || state.hoveredItem) {
                state.isWheelScrolling = false;
                return;
              }
              state.currentId = centerId;
              setHighlight(centerId);

              const targetHeading = document.getElementById(centerId);
              if (targetHeading) {
                driveArticleScroll(centerId, () => {
                  state.isWheelScrolling = false;
                  if (state.activeState === 'menu' && !state.hoveredItem) {
                    state.activeState = 'scroll';
                    setHighlight(state.currentId);
                  }
                });
              } else {
                state.isWheelScrolling = false;
                state.activeState = 'scroll';
                setHighlight(state.currentId);
              }
            }).catch(() => {
              state.isWheelScrolling = false;
            });
          }

          function onTouchEnd() {
            if (state.hoveredItem) state.hoveredItem = null;
            if (state.activeState === 'menu') menuScrollDebounce.call();
          }

          // --- å…¬å¼€æ¥å£ ---

          function init(onItemClick) {
            allHeadings = Array.from(contentEl.querySelectorAll('h1, h2, h3'))
              .filter(h => h.textContent.trim() !== '');
            allHeadings.forEach((el, index) => { el.id = `heading-${index}`; });

            const classMap = { 1: 'h1-item', 2: 'h2-item', 3: 'h3-item' };
            allHeadings.forEach(heading => {
              const listItem       = document.createElement('div');
              const level          = parseInt(heading.tagName[1]);
              listItem.className   = `chapter-item ${classMap[level] || 'h1-item'}`;
              listItem.textContent = heading.textContent;
              listItem.dataset.id  = heading.id;

              listItem.addEventListener('click', (e) => {
                e.stopPropagation();
                state.currentId = heading.id;   // ç«‹å³åŒæ­¥ï¼Œé¿å…èœå•å…³é—­åé«˜äº®å›é€€åˆ°æ—§ç« èŠ‚
                heading.scrollIntoView({ behavior: 'smooth', block: 'start' });
                onItemClick?.();
              });

              chapterListEl.appendChild(listItem);
            });

            if (allHeadings.length > 0) {
              state.currentId = allHeadings[0].id;
              applyScrollState(state.currentId);
            }

            window.addEventListener('scroll', updateActiveHeading, { passive: true });

            // æ»šè½®ï¼šè®¾ç½®å±è”½æ ‡å¿—ï¼Œé˜²æ­¢å‡ pointer äº‹ä»¶å¹²æ‰°
            // ä» hover åˆ‡å‡ºæ—¶ç«‹å³ setHighlightï¼Œæ¸…é™¤æ®‹ç•™çš„ .hovered ç±»ï¼Œé¿å…åŒé«˜äº®
            chapterListEl.addEventListener('wheel', () => {
              if (!state.isWheelScrolling) {
                state.isWheelScrolling = true;
                if (state.activeState === 'hover') {
                  hoverScrollDebounce.cancel();
                  state.hoveredItem = null;
                  state.activeState = 'scroll';
                  setHighlight(state.currentId);
                }
              }
            }, { passive: true });

            // èœå•åˆ—è¡¨æ»šåŠ¨ï¼šå®æ—¶æ›´æ–°é«˜äº®å¹¶è§¦å‘é˜²æŠ–å¸é™„
            chapterListEl.addEventListener('scroll', () => {
              if (state.programmaticScrollCount > 0) return;
              if (state.activeState === 'hover') return;
              state.isMenuScrolling = true;
              state.activeState     = 'menu';
              const realtimeId = getCenteredItemId();
              if (realtimeId) setHighlight(realtimeId);
              menuScrollDebounce.call();
            }, { passive: true });

            // ç§»åŠ¨ç«¯ï¼šæ‰‹æŒ‡ç¦»å¼€æ—¶ç«‹å³è§¦å‘ä¸€æ¬¡é˜²æŠ–ï¼Œæ¯”ç­‰æƒ¯æ€§åœæ­¢å“åº”æ›´å¿«
            chapterListEl.addEventListener('touchend',    onTouchEnd);
            chapterListEl.addEventListener('touchcancel', onTouchEnd);

            if (isDesktop) {
              // äº‹ä»¶å§”æ‰˜ï¼špointerover/pointerout ä¼šå†’æ³¡ï¼Œpointerenter/pointerleave ä¸å†’æ³¡ã€‚
              // pointeroverï¼šä»…åœ¨è¿›å…¥æ–° item ä¸”æ²¡æœ‰ç¨‹åºé©±åŠ¨æ»šåŠ¨æ—¶è§¦å‘
              chapterListEl.addEventListener('pointerover', (e) => {
                if (e.pointerType !== 'mouse') return;
                if (state.isWheelScrolling || state.isHoverScrolling) return;
                const item = e.target.closest('.chapter-item');
                if (item && item !== state.hoveredItem) onItemPointerEnter(item);
              });

              // pointeroutï¼šrelatedTarget ä¸åœ¨å½“å‰ item å†…éƒ¨ã€ä¸”æ²¡æœ‰ç¨‹åºé©±åŠ¨æ»šåŠ¨æ—¶è§¦å‘
              chapterListEl.addEventListener('pointerout', (e) => {
                if (e.pointerType !== 'mouse') return;
                if (state.isWheelScrolling || state.isHoverScrolling) return;
                const item = e.target.closest('.chapter-item');
                if (item && !item.contains(e.relatedTarget)) onItemPointerLeave();
              });

              // pointerleaveï¼ˆæ•´ä¸ªåˆ—è¡¨ï¼‰ï¼šisWheelScrolling/isHoverScrolling æœŸé—´å±è”½
              chapterListEl.addEventListener('pointerleave', (e) => {
                if (e.pointerType !== 'mouse') return;
                if (state.isWheelScrolling || state.isHoverScrolling) return;
                if (state.activeState === 'hover') onItemPointerLeave();
              });
            }
          }

          /** èœå•æ‰“å¼€æ—¶è°ƒç”¨ï¼šå°†å½“å‰é«˜äº®é¡¹å³æ—¶å±…ä¸­ã€‚è¿”å› Promise ä¾›å…¥åœºåŠ¨ç”»ç­‰å¾…ï¼ˆM11 é¢„ç•™ï¼‰ã€‚ */
          function syncToMenu() {
            if (state.currentId) return scrollMenuToItem(state.currentId, 'instant');
            return Promise.resolve();
          }

          /** èœå•å…³é—­æ—¶è°ƒç”¨ï¼šå–æ¶ˆæ‚¬åœçŠ¶æ€ï¼Œå›é€€åˆ° scrollã€‚
           *  æ³¨ï¼šmenuScrollDebounce ä¸åœ¨æ­¤å¤„å–æ¶ˆâ€”â€”onMenuScrollDebounced çš„ finally
           *  è´Ÿè´£ isWheelScrolling å¤ä½ä¸ activeState å›é€€ï¼›è‹¥æ­¤å¤„å¼ºåˆ¶å–æ¶ˆï¼Œ
           *  isWheelScrolling ä¼šæ°¸ä¹…å¡åœ¨ trueï¼Œå¯¼è‡´ pointer äº‹ä»¶å…¨éƒ¨è¢«å±è”½ï¼Œ
           *  å¹¶åœ¨èœå•å…³é—­åè§¦å‘æ„å¤–çš„é«˜äº®å›æ»šã€‚
           */
          function cancelHover() {
            hoverScrollDebounce.cancel();
            state.isHoverScrolling = false;   // ç¡®ä¿ async è·³è½¬ä¸­é€”å…³é—­èœå•æ—¶ä¸ç•™è„çŠ¶æ€
            state.hoveredItem = null;
            if (state.activeState === 'hover') {
              state.activeState = 'scroll';
              setHighlight(state.currentId);
            }
          }

          return { init, syncToMenu, cancelHover };
        }


        // ==================== 7. Reveal æ•ˆæœï¼ˆä»…æ¡Œé¢ï¼‰====================
        /**
         * å°è£…äº†å…¨éƒ¨ Reveal å…‰æ•ˆé€»è¾‘ï¼šCSS å˜é‡æ›´æ–°ã€Canvas åˆ†éš”çº¿å‘å…‰ã€äº‹ä»¶ç»‘å®šã€‚
         * å¯¹å¤–æš´éœ²ä¸¤ä¸ªæ¥å£ï¼š
         *   resizeCanvas()   - èœå•æ‰“å¼€æ—¶è°ƒç”¨ï¼Œåˆå§‹åŒ– canvas å°ºå¯¸
         *   clearAllReveal() - èœå•å…³é—­æ—¶è°ƒç”¨ï¼Œæ¸…é™¤æ‰€æœ‰å…‰æ•ˆ
         */
        function initRevealEffect({ canvasEl, chapterListEl, menuWrapperEl, targets, state }) {
          const ctx = canvasEl.getContext('2d');
          let cachedMenuRect  = null;

          // === æ€§èƒ½ç¼“å­˜ ===
          // â‘  item rect ç¼“å­˜ï¼šèœå•æ‰“å¼€/resize/æ»šåŠ¨ç»“æŸåé‡å»ºï¼Œé¿å… pointermove é«˜é¢‘ reflow
          let cachedItemRects = null;   // { lineY, lineLeft, lineRight }[]
          // â‘¡ é¢œè‰²ç¼“å­˜ï¼šåªåœ¨ä¸»é¢˜åˆ‡æ¢æ—¶ä¼šå˜ï¼Œèœå•æ‰“å¼€æ—¶æ›´æ–°ä¸€æ¬¡å³å¯
          let cachedColorHi   = '';
          let cachedColorMid  = '';
          // â‘¢ rAF èŠ‚æµï¼špointermove åªè®°åæ ‡ï¼Œå®é™…ç»˜åˆ¶åˆå¹¶åˆ°ä¸‹ä¸€å¸§
          let rafPending      = false;
          // â‘£ target rect ç¼“å­˜ï¼šfixed å®šä½å…ƒç´ åªåœ¨ resize / èœå•æ‰“å¼€æ—¶ä½ç½®å˜åŒ–ï¼Œæ— éœ€æ¯å¸§ reflow
          let cachedTargetRects = null; // Map<el, DOMRect>

          const isMenuActive = () => menuWrapperEl.classList.contains('active');

          /** åˆ·æ–° target rect ç¼“å­˜ã€‚alwaysOn å…ƒç´ å§‹ç»ˆç¼“å­˜ï¼›å…¶ä½™åªåœ¨èœå•æ¿€æ´»æ—¶æ‰æœ‰æœ‰æ•ˆä½ç½®ã€‚ */
          function refreshTargetRects() {
            cachedTargetRects = new Map();
            targets.forEach(({ el, alwaysOn }) => {
              if (alwaysOn || isMenuActive()) {
                cachedTargetRects.set(el, el.getBoundingClientRect());
              }
            });
          }

          /** æ„å»º item rect ç¼“å­˜ï¼ˆç›¸å¯¹äº menuRectï¼‰ï¼Œä½¿ç”¨è°ƒç”¨æ–¹å·²æœ‰çš„ menuRect é¿å…é‡å¤ reflowã€‚ */
          function buildItemRectCache(menuRect) {
            cachedItemRects = Array.from(
              chapterListEl.querySelectorAll('.chapter-item:not(:last-child)')
            ).map(item => {
              const r = item.getBoundingClientRect();
              return {
                lineY:     r.bottom - menuRect.top,
                lineLeft:  r.left   - menuRect.left + 8,
                lineRight: r.right  - menuRect.left - 8,
              };
            });
          }

          /** æ›´æ–°é¢œè‰²ç¼“å­˜ã€‚ */
          function updateColorCache() {
            const style    = getComputedStyle(document.body);
            cachedColorHi  = style.getPropertyValue('--reveal-hi').trim();
            cachedColorMid = style.getPropertyValue('--reveal-mid').trim();
          }

          function resizeCanvas() {
            if (!isMenuActive()) return;
            const r = chapterListEl.getBoundingClientRect();
            canvasEl.width       = r.width;
            canvasEl.height      = r.height;
            canvasEl.style.left  = r.left + 'px';
            canvasEl.style.top   = r.top  + 'px';
            cachedMenuRect = r;
            updateColorCache();
            cachedItemRects   = null;
            // target rect ç¼“å­˜ï¼šmenuAppear åŠ¨ç”»æœŸé—´ getBoundingClientRect è¿”å›å˜æ¢ä¸­çš„å°å°ºå¯¸ï¼Œ
            // å…ˆç½® nullï¼ˆhandleMove ä¼šå®æ—¶å– rect é™çº§ï¼‰ï¼ŒåŠ¨ç”»ç»“æŸåå†æ­£å¼ç¼“å­˜ã€‚
            cachedTargetRects = null;
            const wrapper = menuWrapperEl;
            const onAnimEnd = () => {
              wrapper.removeEventListener('animationend', onAnimEnd);
              if (isMenuActive()) refreshTargetRects();
            };
            // è‹¥èœå•å·²æ— åŠ¨ç”»åœ¨è·‘ï¼ˆå¦‚ resize æ—¶ï¼‰ï¼Œanimationend ä¸ä¼šè§¦å‘ï¼›
            // ç”¨ getAnimations() åˆ¤æ–­ï¼Œè‹¥æ— åŠ¨ç”»åˆ™ç«‹å³åˆ·æ–°ã€‚
            if (wrapper.getAnimations().length > 0) {
              wrapper.addEventListener('animationend', onAnimEnd);
            } else {
              refreshTargetRects();
            }
          }

          const redrawAfterScroll = createDebounce(() => {
            if (isMenuActive()) {
              resizeCanvas();  // å†…éƒ¨å·²åŒ…å« buildItemRectCache
              drawDividerGlow(state.lastMouseX, state.lastMouseY);
            }
          }, 150);

          // èœå•å†…éƒ¨æ»šåŠ¨æ—¶ï¼šç«‹å³æ¸…é™¤ç”»é¢ï¼Œå¹¶å°† item ç¼“å­˜ç½®ä¸º nullï¼ˆä½ç½®å·²å¤±æ•ˆï¼‰ï¼›
          // é˜²æŠ–ç»“æŸå resizeCanvas ä¼šé‡å»ºç¼“å­˜å†é‡ç»˜ã€‚
          // æ³¨æ„ï¼šæ­¤ handler ç”± openMenu/closeMenu é€šè¿‡ attachScrollListener /
          //       detachScrollListener ç®¡ç†ï¼Œè€Œéåœ¨ initRevealEffect å†…ç›´æ¥ç»‘å®šï¼Œ
          //       ä»¥ä¾¿èœå•å…³é—­åå½»åº•è§£é™¤ï¼ŒåŒæ—¶ä¿ç•™ menuToggle çš„ pointermove Revealã€‚
          function _onChapterScroll() {
            if (isMenuActive()) {
              cachedItemRects = null;
              requestAnimationFrame(() => {
                ctx.clearRect(0, 0, canvasEl.width, canvasEl.height);
              });
              redrawAfterScroll.call();
            }
          }

          function attachScrollListener() {
            chapterListEl.addEventListener('scroll', _onChapterScroll, { passive: true });
          }

          function detachScrollListener() {
            chapterListEl.removeEventListener('scroll', _onChapterScroll);
            redrawAfterScroll.cancel();   // å–æ¶ˆæœªè§¦å‘çš„é˜²æŠ–ï¼Œé¿å…èœå•å…³é—­åæ®‹ç•™é‡ç»˜
          }

          function drawDividerGlow(mouseX, mouseY) {
            ctx.clearRect(0, 0, canvasEl.width, canvasEl.height);
            if (!isMenuActive()) return;

            const colorHi  = cachedColorHi;
            const colorMid = cachedColorMid;

            // å…¨å±€åªå–ä¸€æ¬¡ rectï¼Œæ ¡éªŒã€ç¼“å­˜æ„å»ºéƒ½ç”¨è¿™åŒä¸€ä¸ªå€¼
            const menuRect = chapterListEl.getBoundingClientRect();

            // å°ºå¯¸/ä½ç½®æ ¡éªŒï¼šcanvas ä¸å®é™…ä½ç½®ä¸ç¬¦æ—¶ä¿®æ­£ï¼Œå¹¶åŒæ­¥ä½œåºŸ item ç¼“å­˜
            if (canvasEl.width  !== Math.round(menuRect.width)  ||
                canvasEl.height !== Math.round(menuRect.height) ||
                parseFloat(canvasEl.style.left) !== menuRect.left ||
                parseFloat(canvasEl.style.top)  !== menuRect.top) {
              canvasEl.width      = menuRect.width;
              canvasEl.height     = menuRect.height;
              canvasEl.style.left = menuRect.left + 'px';
              canvasEl.style.top  = menuRect.top  + 'px';
              cachedMenuRect      = menuRect;
              cachedItemRects     = null;   // canvas å°ºå¯¸å˜äº†ï¼Œæ—§ç¼“å­˜åæ ‡å·²å¤±æ•ˆ
            }

            const radius = 80;
            if (distToRect(mouseX, mouseY, menuRect) > radius) return;

            // æ‡’åŠ è½½ï¼šä¼ å…¥å·²æœ‰çš„ menuRectï¼Œé¿å…å†æ¬¡ reflow
            if (!cachedItemRects) buildItemRectCache(menuRect);

            cachedItemRects.forEach(({ lineY, lineLeft, lineRight }) => {
              if (lineY < 0 || lineY > canvasEl.height) return;

              const nearestX = Math.max(lineLeft, Math.min(mouseX - menuRect.left, lineRight));
              const dist     = Math.hypot(
                mouseX - menuRect.left - nearestX,
                mouseY - menuRect.top  - lineY
              );
              if (dist > radius) return;

              const intensity = 1 - dist / radius;
              const gx   = mouseX - menuRect.left;
              const grad = ctx.createRadialGradient(gx, lineY, 0, gx, lineY, radius);
              grad.addColorStop(0,   `rgba(${colorHi},${intensity})`);
              grad.addColorStop(0.4, `rgba(${colorMid},${0.65 * intensity})`);
              grad.addColorStop(1,   `rgba(${colorMid},0)`);

              ctx.beginPath();
              ctx.moveTo(lineLeft,  lineY);
              ctx.lineTo(lineRight, lineY);
              ctx.lineWidth   = 1;
              ctx.strokeStyle = grad;
              ctx.stroke();
            });
          }

          function clearAllReveal() {
            targets.forEach(({ el }) => clearRevealVar(el));
            ctx.clearRect(0, 0, canvasEl.width, canvasEl.height);
            canvasEl.classList.remove('active');
            rafPending = false;
          }

          function handleMove(e) {
            if (e.pointerType && e.pointerType !== 'mouse') return;
            state.lastMouseX = e.clientX;
            state.lastMouseY = e.clientY;
            const menuActive = isMenuActive();

            // CSS å˜é‡æ›´æ–°ï¼šä¸æ¶‰åŠç»˜åˆ¶ï¼Œç›´æ¥åŒæ­¥æ‰§è¡Œï¼ˆå¼€é”€å¾ˆä½ï¼‰
            // ä½¿ç”¨ç¼“å­˜ rectï¼Œé¿å…æ¯æ¬¡ pointermove å¯¹ fixed å…ƒç´ é‡å¤ reflow
            if (!cachedTargetRects) refreshTargetRects();
            targets.forEach(({ el, range, alwaysOn, distFn }) => {
              if (!alwaysOn && !menuActive) { clearRevealVar(el); return; }
              // alwaysOn å…ƒç´ ï¼ˆmenuToggleï¼‰ä¼šå›  display:none å¯¼è‡´ç¼“å­˜ rect å¤±æ•ˆï¼Œ
              // ç›´æ¥å®æ—¶è·å–ï¼Œå¼€é”€å¯å¿½ç•¥ï¼ˆfixed å…ƒç´ ï¼Œæ¯æ¬¡ pointermove åªç®—ä¸€æ¬¡ï¼‰ã€‚
              const rect = alwaysOn ? null : (cachedTargetRects.get(el) ?? null);
              updateRevealVar(el, e.clientX, e.clientY, range, distFn, rect);
            });

            // Canvas ç»˜åˆ¶ï¼šrAF èŠ‚æµï¼Œæ¯å¸§æœ€å¤šæ‰§è¡Œä¸€æ¬¡ï¼Œåˆå¹¶é«˜é¢‘ pointermove
            if (menuActive) {
              if (!cachedMenuRect) resizeCanvas();
              canvasEl.classList.add('active');
              if (!rafPending) {
                rafPending = true;
                requestAnimationFrame(() => {
                  rafPending = false;
                  if (isMenuActive()) drawDividerGlow(state.lastMouseX, state.lastMouseY);
                });
              }
            }
          }

          document.addEventListener('pointermove',  handleMove);
          document.addEventListener('pointerup',    handleMove);
          document.addEventListener('pointerleave', clearAllReveal);
          window.addEventListener('blur',           clearAllReveal);

          function handleResize() {
            cachedMenuRect  = null;
            cachedItemRects = null;
            resizeCanvas();
          }

          return { resizeCanvas, clearAllReveal, handleResize, attachScrollListener, detachScrollListener };
        }


        // ==================== 8. Mica é¢œè‰²é‡‡æ ·å™¨ ====================
        /**
         * é€šè¿‡ document.elementFromPoint ç½‘æ ¼é‡‡æ ·è§†å£ä¸­å¿ƒåŒºåŸŸçš„ä¸»è‰²è°ƒï¼Œ
         * ç» HSL åç§»åå†™å…¥ CSS å˜é‡ï¼Œä¾›äº”å±‚ç»“æ„å’Œ Reveal æ•ˆæœä½¿ç”¨ã€‚
         * é‡‡æ ·å¤±è´¥ï¼ˆå«è·¨åŸŸ SecurityErrorï¼‰æ—¶é™é»˜é™çº§ï¼Œä¿ç•™ CSS é»˜è®¤å€¼ã€‚
         *
         * å¯¹å¤–æš´éœ²ï¼šsample() â†’ Promise<void>
         */
        function createMicaSampler() {
          function parseRgba(str) {
            const m = str.match(/rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)/);
            return m ? [+m[1], +m[2], +m[3]] : null;
          }
          function isOpaque(bg) {
            if (!bg || bg === 'transparent') return false;
            const m = bg.match(/rgba\([^)]+,\s*([\d.]+)\s*\)/);
            return !(m && parseFloat(m[1]) < 0.05);
          }
          // åˆ¤æ–­é¢œè‰²æ˜¯å¦æœ‰è¶³å¤Ÿé¥±å’Œåº¦ï¼ˆè¿‡æ»¤ç°è‰²/é»‘è‰²/ç™½è‰²èƒŒæ™¯ï¼Œè¿™äº›æ²¡æœ‰æœ‰æ•ˆè‰²å½©ä¿¡æ¯ï¼‰
          function hasSaturation(rgb) {
            const [r, g, b] = rgb;
            const max = Math.max(r, g, b), min = Math.min(r, g, b);
            const l = (max + min) / 510;  // å½’ä¸€åŒ– L
            if (l < 0.05 || l > 0.95) return false;  // è¿‡æš—æˆ–è¿‡äº®ï¼ˆæ¥è¿‘çº¯é»‘/çº¯ç™½ï¼‰
            const s = l > 0.5 ? (max - min) / (510 - max - min) : (max - min) / (max + min);
            return s > 0.12;  // é¥±å’Œåº¦é˜ˆå€¼ 12%ï¼Œè¿‡æ»¤æ— å½©è‰²
          }
          function rgbToHsl(r, g, b) {
            r /= 255; g /= 255; b /= 255;
            const max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h = 0, s = 0, l = (max + min) / 2;
            if (max !== min) {
              const d = max - min;
              s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
              switch (max) {
                case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                case g: h = ((b - r) / d + 2) / 6; break;
                case b: h = ((r - g) / d + 4) / 6; break;
              }
            }
            return [h * 360, s * 100, l * 100];
          }
          function hslToRgb(h, s, l) {
            h /= 360; s /= 100; l /= 100;
            if (s === 0) { const v = Math.round(l * 255); return [v, v, v]; }
            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;
            const hue2rgb = (p, q, t) => {
              if (t < 0) t += 1; if (t > 1) t -= 1;
              if (t < 1/6) return p + (q - p) * 6 * t;
              if (t < 1/2) return q;
              if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
              return p;
            };
            return [
              Math.round(hue2rgb(p, q, h + 1/3) * 255),
              Math.round(hue2rgb(p, q, h)       * 255),
              Math.round(hue2rgb(p, q, h - 1/3) * 255),
            ];
          }
          function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

          async function sample() {
            try {
              const vw = window.innerWidth, vh = window.innerHeight;
              const cx = vw / 2, cy = vh / 2;
              const rx = vw * 0.1, ry = vh * 0.1;   // è§†å£ä¸­å¿ƒ 20%Ã—20% åŒºåŸŸ
              const GRID = 4;
              const colors = [];

              for (let i = 0; i < GRID; i++) {
                for (let j = 0; j < GRID; j++) {
                  const x = cx - rx + rx * 2 * i / (GRID - 1);
                  const y = cy - ry + ry * 2 * j / (GRID - 1);
                  let el = document.elementFromPoint(x, y);
                  // å‘ä¸Šéå† DOM æ ‘ï¼Œæ‰¾ç¬¬ä¸€ä¸ªä¸é€æ˜èƒŒæ™¯è‰²
                  while (el && el !== document.documentElement) {
                    const bg = getComputedStyle(el).backgroundColor;
                    if (isOpaque(bg)) {
                      const rgb = parseRgba(bg);
                      if (rgb) { colors.push(rgb); break; }
                    }
                    el = el.parentElement;
                  }
                }
              }
              if (colors.length === 0) return;   // é‡‡æ ·ä¸ºç©ºï¼Œé™é»˜é™çº§

              // è®¡ç®—åŒºåŸŸå¹³å‡è‰²
              const [rA, gA, bA] = colors
                .reduce((a, c) => [a[0]+c[0], a[1]+c[1], a[2]+c[2]], [0,0,0])
                .map(v => Math.round(v / colors.length));

              const [h, s, l] = rgbToHsl(rA, gA, bA);

              // HSL åç§»ï¼š+45% äº®åº¦ â†’ å…‰æ•ˆé«˜äº®è‰²ï¼›-45% äº®åº¦ â†’ æ·±è‰²å±‚
              // mid æ¯” hi ä½ 20% Lï¼Œåˆ¶é€ è‚‰çœ¼å¯è¾¨çš„æ¸å˜å±‚æ¬¡ï¼›é¥±å’Œåº¦ç•¥é™ä½¿è¿‡æ¸¡æ›´è‡ªç„¶
              const lHi    = clamp(l + 45, 0, 100);
              const lMid   = clamp(lHi - 20, 0, 100);  // æ˜æ˜¾ä½äº hiï¼Œç¡®ä¿æ¸å˜å¯è§
              const lDark  = clamp(l - 45, 0, 100);
              const sDim   = s * 0.82;

              const rgbHi    = hslToRgb(h, s,    lHi);
              const rgbMid   = hslToRgb(h, sDim, lMid); // ä½äº®åº¦ç‰ˆï¼Œä¸ hi å½¢æˆå¯¹æ¯”
              const rgbDarkL = hslToRgb(h, s,   lDark);
              const rgbDarkR = hslToRgb(h, sDim, clamp(lDark + 3, 0, 100));

              document.body.style.setProperty('--reveal-hi',       rgbHi.join(', '));
              document.body.style.setProperty('--reveal-mid',      rgbMid.join(', '));
              document.body.style.setProperty('--mica-dark-left',  rgbDarkL.join(', '));
              document.body.style.setProperty('--mica-dark-right', rgbDarkR.join(', '));

              // Mica è”åŠ¨ floating-btnï¼šå†™å…¥æ’å€¼ç«¯ç‚¹ï¼Œç”± updateProgress è´Ÿè´£æŒ‰è¿›åº¦æ’å€¼
              // --mica-btn-dark: åˆå§‹è‰²ï¼ˆåŸ 0,0,0 ä½ç½®ï¼‰ï¼›--mica-btn-hi: æœ€äº®è‰²ï¼ˆåŸ 255,0,0 ä½ç½®ï¼‰
              _micaBtnDark = rgbDarkL;   // æ¨¡å—çº§å˜é‡ï¼Œä¾› updateProgress è¯»å–
              _micaBtnHi   = rgbHi;
              _micaActive  = true;       // å‘ŠçŸ¥ updateProgress ä½¿ç”¨ Mica ç«¯ç‚¹è€Œéç¡¬ç¼–ç 
              updateProgress();          // ç«‹å³ä»¥æ–°ç«¯ç‚¹åˆ·æ–°ä¸€æ¬¡æŒ‰é’®é¢œè‰²
            } catch (_) {
              // é™é»˜é™çº§ï¼šè·¨åŸŸ SecurityError æˆ–å…¶ä»–å¼‚å¸¸ï¼Œä¿ç•™ CSS å˜é‡ç°æœ‰é»˜è®¤å€¼
            }
          }

          return { sample };
        }


        // ==================== 9. ä¸»åˆå§‹åŒ– ====================

        // --- åˆ›å»ºé«˜äº®å™¨ï¼ˆæ­¤æ—¶ closeMenu å°šæœªå®šä¹‰ï¼Œé€šè¿‡å›è°ƒæ³¨å…¥ï¼‰---
        const highlighter = createChapterHighlighter({
          contentEl:    document.querySelector('.content'),
          chapterListEl: chapterList,
          isDesktop,
          state,
        });

        // --- Mica é‡‡æ ·å™¨ï¼ˆM5ï¼‰---
        const micaSampler = createMicaSampler();

        /**
         * buildMenuLayersï¼ˆM6ï¼‰ï¼šå‘ .side-menu æ³¨å…¥äº”å±‚ç»“æ„ DOMã€‚
         * å¹‚ç­‰è®¾è®¡ï¼šæ£€æµ‹ .menu-layer-base æ˜¯å¦å·²å­˜åœ¨ï¼Œé˜²æ­¢é‡å¤æ’å…¥ã€‚
         * åœ¨åˆå§‹åŒ–é˜¶æ®µæ‰§è¡Œä¸€æ¬¡ï¼Œèœå•å…³é—­/æ‰“å¼€ä¸ä¼šé‡æ–°åˆ›å»ºã€‚
         */
        function buildMenuLayers() {
          if (sideMenu.querySelector('.menu-layer-base')) return;
          const fragment = document.createDocumentFragment();
          ['base', 'light', 'acrylic', 'texture'].forEach(name => {
            const layer = document.createElement('div');
            layer.className = `menu-layer-${name}`;
            fragment.appendChild(layer);
          });
          // æ’å…¥åˆ° menu-left ä¹‹å‰ï¼Œç¡®ä¿åœ¨æ–‡æ¡£æµä¸Šå¤„äºåº•éƒ¨ï¼ˆz-index æ§åˆ¶å®é™…ç»˜åˆ¶é¡ºåºï¼‰
          sideMenu.insertBefore(fragment, sideMenu.firstChild);
        }
        buildMenuLayers();

        // --- èœå•æ§åˆ¶ï¼ˆUI å±‚æ“ä½œ + è°ƒç”¨å„æ¨¡å—æ¥å£ï¼‰---
        async function openMenu() {
          state.isWheelScrolling = false;        // é˜²å¾¡ï¼šå…³/å¼€èœå•ä¹‹é—´è‹¥ debounce å°šæœªè§¦å‘ï¼Œå¤ä½å±è”½æ ‡å¿—
          // M5 Fix3: å¿…é¡»åœ¨èœå•æ˜¾ç¤ºä¹‹å‰é‡‡æ ·ï¼Œå¦åˆ™èœå•è¦†ç›–è§†å£ï¼Œåªèƒ½é‡‡åˆ°èœå•è‡ªèº«çš„ç°è‰²
          await micaSampler.sample();
          sideMenuWrapper.classList.add('active');
          sideMenu.classList.add('active');
          menuMask.classList.add('active');
          menuToggle.style.display = 'none';
          highlighter.syncToMenu();
          if (isDesktop) {
            reveal.resizeCanvas();               // è¯»å–é¢œè‰²ç¼“å­˜ï¼ˆåœ¨ Mica ä¹‹åï¼‰
            reveal.attachScrollListener();
          }
        }

        function closeMenu() {
          sideMenuWrapper.classList.remove('active');
          sideMenu.classList.remove('active');
          menuMask.classList.remove('active');
          menuToggle.style.display = 'flex';
          if (isDesktop) {
            reveal.detachScrollListener();  // ä»…ç§»é™¤ canvas scroll ç›‘å¬ï¼Œä¿ç•™ menuToggle Reveal
            reveal.clearAllReveal();
          }
          highlighter.cancelHover();
        }

        // --- åˆå§‹åŒ–é«˜äº®å™¨ï¼ˆä¼ å…¥ closeMenu ä½œä¸º item ç‚¹å‡»å›è°ƒï¼‰---
        highlighter.init(closeMenu);

        // --- åˆå§‹åŒ– Revealï¼ˆä»…æ¡Œé¢ï¼‰---
        let reveal = null;
        if (isDesktop) {
          reveal = initRevealEffect({
            canvasEl:      document.getElementById('menuRevealCanvas'),
            chapterListEl: chapterList,
            menuWrapperEl: sideMenuWrapper,
            targets: [
              { el: menuToggle,      range: 60, alwaysOn: true,  distFn: distToRect    },
              { el: sideMenuWrapper, range: 80, alwaysOn: false, distFn: distToRect    },
              { el: menuRightEl,     range: 80, alwaysOn: false, distFn: distToRect    },
              { el: closeBtn,        range: 80, alwaysOn: false, distFn: distToTopEdge },
            ],
            state,
          });
        }

        // resize åŒæ­¥è¿›åº¦æ¡é¢œè‰² + canvas å°ºå¯¸ï¼ˆåˆå¹¶ä¸ºå•ä¸€ç›‘å¬å™¨ï¼Œæ¡Œé¢/ç§»åŠ¨ç«¯å‡ç”Ÿæ•ˆï¼‰
        window.addEventListener('resize', () => {
          if (reveal) reveal.handleResize();
          updateProgress();
        }, { passive: true });

        // --- æŒ‰é’®äº‹ä»¶ ---
        menuToggle.addEventListener('click',  (e) => { e.stopPropagation(); openMenu(); });
        closeBtn.addEventListener('click',    (e) => { e.stopPropagation(); closeMenu(); });
        menuMask.addEventListener('click',    (e) => { e.stopPropagation(); closeMenu(); });
        sideMenu.addEventListener('click',    (e) => e.stopPropagation());

        toBottomBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
          closeMenu();
        });

        middleBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          const middle = (document.documentElement.scrollHeight - window.innerHeight) / 2;
          window.scrollTo({ top: middle, behavior: 'smooth' });
          closeMenu();
        });

        toTopBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          window.scrollTo({ top: 0, behavior: 'smooth' });
          closeMenu();
        });

        // ==================== 10. æ»šåŠ¨è¿›åº¦æŒ‡ç¤ºå™¨ ====================
        // _lastBgValue:  ç¼“å­˜ä¸Šæ¬¡å†™å…¥çš„èƒŒæ™¯è‰² R å€¼ï¼Œé¿å…æœªå˜æ—¶é‡å¤ style å†™å…¥
        // _micaActive:   Mica é‡‡æ ·æˆåŠŸåç½® trueï¼ŒupdateProgress æ”¹ç”¨ Mica ç«¯ç‚¹æ’å€¼
        // _micaBtnDark:  Mica æ·±è‰²ç«¯ç‚¹ [r,g,b]ï¼ˆæ›¿ä»£ç¡¬ç¼–ç  0,0,0ï¼‰
        // _micaBtnHi:    Mica äº®è‰²ç«¯ç‚¹ [r,g,b]ï¼ˆæ›¿ä»£ç¡¬ç¼–ç  255,0,0ï¼‰
        let _lastBgValue = -1;
        let _micaActive  = false;
        let _micaBtnDark = [0,   0,   0];
        let _micaBtnHi   = [255, 0,   0];

        function updateProgress() {
          const scrollHeight  = document.documentElement.scrollHeight - window.innerHeight;
          const scrollPercent = scrollHeight > 0 ? Math.min(window.scrollY / scrollHeight, 1) : 0;
          const t = scrollPercent;   // 0ï¼ˆé¡¶éƒ¨ï¼‰â†’ 1ï¼ˆåº•éƒ¨ï¼‰

          // æŒ‰é’®èƒŒæ™¯è‰²ï¼šåœ¨ dark/hi ä¸¤ç«¯ç‚¹ä¹‹é—´æŒ‰è¿›åº¦æ’å€¼
          const [dr, dg, db] = _micaBtnDark;
          const [hr, hg, hb] = _micaBtnHi;
          const bgR = Math.round(dr + (hr - dr) * t);
          const bgG = Math.round(dg + (hg - dg) * t);
          const bgB = Math.round(db + (hb - db) * t);
          // ç”¨åˆå¹¶å€¼åšè„æ£€æµ‹ï¼ˆé¿å…ä¸‰é€šé“å„è‡ªæ¯”è¾ƒï¼‰
          const bgPacked = (bgR << 16) | (bgG << 8) | bgB;
          if (bgPacked !== _lastBgValue) {
            _lastBgValue = bgPacked;
            menuToggle.style.backgroundColor = `rgb(${bgR}, ${bgG}, ${bgB})`;
            // èƒŒæ™¯å§‹ç»ˆä¸ºæ·±è‰²ç³»ï¼Œå­—è‰²å›ºå®šç™½è‰²ä¿è¯å¯è¯»æ€§ï¼ˆæ—¥é—´/å¤œé—´å‡é€‚ç”¨ï¼‰
            menuToggle.style.color = '#fff';
          }

          // --toggle-hi/mid/glowï¼šMica ç«¯ç‚¹æ’å€¼ï¼ˆMica æ¿€æ´»ï¼‰æˆ–ä¸»é¢˜ç¡¬ç¼–ç æ’å€¼ï¼ˆé™çº§ï¼‰
          let hiColor, midColor;
          if (_micaActive) {
            // Mica æ¨¡å¼ï¼šhi ç«¯ï¼ˆæœ€äº®ï¼‰ç›´æ¥ç”¨ _micaBtnHiï¼Œmid ç«¯ç”¨ä¸­é—´å€¼
            hiColor  = `${hr}, ${hg}, ${hb}`;
            const mr = Math.round(dr + (hr - dr) * 0.5);
            const mg = Math.round(dg + (hg - dg) * 0.5);
            const mb = Math.round(db + (hb - db) * 0.5);
            midColor = `${mr}, ${mg}, ${mb}`;
          } else {
            // ç¡¬ç¼–ç é™çº§ï¼šä¸åŸé€»è¾‘ä¸€è‡´
            const isLight   = _isLightMode;
            const fadeRatio = 1 - t;
            if (isLight) {
              const r  = Math.round(20  + 60  * fadeRatio);
              const g  = Math.round(20  + 60  * fadeRatio);
              const b  = Math.round(60  + 120 * fadeRatio);
              const r2 = Math.round(15  + 45  * fadeRatio);
              const b2 = Math.round(50  + 110 * fadeRatio);
              hiColor  = `${r}, ${g}, ${b}`;
              midColor = `${r2}, ${g}, ${b2}`;
            } else {
              const gb    = Math.round(255 * (1 - fadeRatio));
              const midR  = Math.round(180 * fadeRatio + 255 * (1 - fadeRatio));
              const midGB = Math.round(gb * 0.5);
              hiColor  = `255, ${gb}, ${gb}`;
              midColor = `${midR}, ${midGB}, ${midGB}`;
            }
          }
          // --toggle-glow: é¢„æ„å»ºå®Œæ•´ rgba()ï¼Œé¿å… rgba(var(),alpha) è·¨æµè§ˆå™¨è§£ææ­§ä¹‰
          document.body.style.setProperty('--toggle-hi',   hiColor);
          document.body.style.setProperty('--toggle-mid',  midColor);
          document.body.style.setProperty('--toggle-glow', `rgba(${hiColor}, 0.45)`);
        }

        window.addEventListener('scroll', updateProgress, { passive: true });
        updateProgress();

      </script>

   </body>

</html>