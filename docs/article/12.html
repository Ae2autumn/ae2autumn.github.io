<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SB - ğ€ğğŸğšğ®ğ­ğ®ğ¦ğ§</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="icon" href="https://avatars.githubusercontent.com/u/195545824?v=4">
    <style>
        /* ==================== CSSå˜é‡ä¸ä¸»é¢˜ç³»ç»Ÿ ==================== */
        :root {
            /* ä¸»é¢˜é¢œè‰² - é»˜è®¤æ·±è‰² */
            --bg-primary: #0d0d0d;
            --text-primary: #fff;
            --text-secondary: #ccc;
            --text-tertiary: #999;
            --border-color: #333;
            --tag-bg: #333;
            --tag-text: #fff;
            --code-bg: #2d2d2d;
            --code-text: #f8f8f2;
            --blockquote-bg: #2a2a2a;
            --blockquote-text: #ccc;
            --blockquote-border: #555;
            --table-header-bg: #333;
            --table-border: #444;
            --link-color: #6bb8ff;
            --link-hover-bg: rgba(107, 184, 255, 0.1);
            
            /* å…‰æ•ˆé¢œè‰² */
            --reveal-hi: 255, 0, 0;
            --reveal-mid: 180, 30, 30;
            
            /* å¸ƒå±€å˜é‡ */
            --content-max-width: 1000px;
            --spacing-base: 20px;
            --border-radius-base: 4px;
            --border-radius-lg: 12px;
            --border-radius-circle: 50%;
            
            /* åŠ¨ç”»æ—¶é•¿ */
            --transition-fast: 0.2s;
            --transition-base: 0.3s;
            --transition-slow: 0.5s;
            
            /* å±‚çº§ */
            --z-canvas: 1001;
            --z-floating-btn: 1000;
            --z-menu: 999;
            --z-mask: 998;
            
            /* å“åº”å¼æ–­ç‚¹ */
            --breakpoint-mobile: 768px;
            --breakpoint-tablet: 1024px;
        }

        /* æµ…è‰²ä¸»é¢˜å˜é‡ */
        body.light-mode {
            --bg-primary: #fff;
            --text-primary: #000;
            --text-secondary: #666;
            --text-tertiary: #777;
            --border-color: #ddd;
            --tag-bg: #eee;
            --tag-text: #000;
            --code-bg: #f5f5f5;
            --code-text: #333;
            --blockquote-bg: #f9f9f9;
            --blockquote-text: #666;
            --blockquote-border: #ddd;
            --table-header-bg: #f5f5f5;
            --table-border: #ddd;
            --link-color: #4da6ff;
            --link-hover-bg: rgba(77, 166, 255, 0.1);
            
            --reveal-hi: 80, 80, 180;
            --reveal-mid: 60, 60, 160;
        }

        /* ==================== åŸºç¡€é‡ç½® ==================== */
        *, *::before, *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            background-color: var(--bg-primary);
            color: var(--text-primary);
            font-family: Arial, sans-serif;
            line-height: 1.6;
            padding: var(--spacing-base);
            max-width: var(--content-max-width);
            margin: 0 auto;
            position: relative;
            transition: background-color var(--transition-slow) ease, 
                        color var(--transition-slow) ease;
            overflow-x: hidden;
            word-wrap: break-word;
            word-break: break-word;
            overflow-wrap: break-word;
        }

        /* ==================== æ–‡ç« å¤´éƒ¨ ==================== */
        .header {
            margin-bottom: 9px;
            padding: var(--spacing-base);
            padding-bottom: 3px;
            border-bottom: 1px solid var(--border-color);
            transition: border-color var(--transition-slow) ease;
        }

        .title {
            font-size: 2.5rem;
            margin-bottom: 3px;
            color: var(--text-primary);
            transition: color var(--transition-slow) ease;
        }

        .summary {
            font-size: 1.1rem;
            margin-bottom: 3px;
            color: var(--text-secondary);
            transition: color var(--transition-slow) ease;
        }

        .date {
            color: var(--text-tertiary);
            font-size: 0.9rem;
            margin-bottom: 3px;
            transition: color var(--transition-slow) ease;
        }

        .tags {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 3px;
        }

        .tag {
            background-color: var(--tag-bg);
            color: var(--tag-text);
            padding: 2px 10px;
            border-radius: 3px;
            font-size: 0.9rem;
            transition: background-color var(--transition-slow) ease, 
                        color var(--transition-slow) ease;
        }

        /* ==================== æ–‡ç« å†…å®¹ ==================== */
        .content {
            padding: var(--spacing-base);
            padding-top: 0;
            margin-bottom: 50px;
            transition: color var(--transition-slow) ease;
            overflow-x: hidden;
        }

        .content p {
            margin-top: 0;
            margin-bottom: 0.3em;
            line-height: 1.5;
        }

        .content h1, .content h2, .content h3,
        .content h4, .content h5, .content h6 {
            margin: 1.5em 0 0.5em;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
            transition: border-color var(--transition-slow) ease, 
                        color var(--transition-slow) ease;
            color: var(--text-primary);
        }

        .content ul, .content ol {
            margin: 0.8em 0;
            padding-left: 2em;
        }

        .content li {
            margin: 0.3em 0;
            line-height: 1.6;
        }

        .content pre {
            margin: 1em 0;
            padding: 1em;
            background-color: var(--code-bg);
            color: var(--code-text);
            border-radius: var(--border-radius-base);
            overflow-x: auto;
            white-space: pre;
            max-width: 100%;
        }

        .content code {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.9em;
        }

        .content p code {
            background-color: var(--code-bg);
            color: var(--code-text);
            padding: 0.2em 0.4em;
            border-radius: 3px;
        }

        .content blockquote {
            margin: 1em 0;
            padding: 0.5em 1em;
            border-left: 4px solid var(--blockquote-border);
            background-color: var(--blockquote-bg);
            color: var(--blockquote-text);
            border-radius: 5px;
        }

        .table-wrapper {
            overflow-x: auto;
            margin: 20px 0;
            max-width: 100%;
        }

        .content table {
            margin: 1em 0;
            border-collapse: collapse;
            width: 100%;
            max-width: 100%;
        }

        .content th, .content td {
            border: 1px solid var(--table-border);
            padding: 0.5em 1em;
            text-align: left;
            max-width: 300px;
        }

        .content th {
            background-color: var(--table-header-bg);
            font-weight: 600;
        }

        .content img {
            max-width: 100%;
            height: auto;
            margin: 1em 0;
            border-radius: var(--border-radius-base);
            display: block;
        }

        .content hr {
            margin: 2em 0;
            border: none;
            border-top: 1px solid var(--border-color);
        }

        .content a {
            color: var(--link-color);
            text-decoration: none;
            border-bottom: 1px dotted rgba(77, 166, 255, 0.5);
            transition: all var(--transition-base) ease;
        }

        .content a:hover {
            color: var(--text-primary);
            border-bottom: 1px solid rgba(77, 166, 255, 0.8);
            background-color: var(--link-hover-bg);
        }

        /* ==================== è¯„è®ºåŒº ==================== */
        .comments {
            margin-top: 50px;
            padding: var(--spacing-base);
            border-top: 1px solid var(--border-color);
            transition: border-color var(--transition-slow) ease;
        }

        /* ==================== æµ®åŠ¨æŒ‰é’® ==================== */
        .floating-btn {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 60px;
            height: 60px;
            border-radius: var(--border-radius-circle);
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            font-size: 24px;
            z-index: var(--z-floating-btn);
            border: 1px solid rgba(255, 255, 255, 0.12);
            outline: none;
            background: rgba(20, 20, 20, 0.55);
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            transition: background var(--transition-base) ease, 
                        border-color var(--transition-base) ease;
        }

        body.is-desktop .floating-btn {
            border: none;
        }

        body.light-mode .floating-btn {
            background: rgba(255, 255, 255, 0.55);
            border-color: rgba(0, 0, 0, 0.1);
            color: #000;
        }

        /* æµ®åŠ¨æŒ‰é’®å…‰æ•ˆ */
        .floating-btn::before {
            content: '';
            position: absolute;
            inset: -1px;
            padding: 1px;
            border-radius: var(--border-radius-circle);
            -webkit-mask: linear-gradient(#fff 0 0) content-box, 
                         linear-gradient(#fff 0 0);
            -webkit-mask-composite: xor;
            mask-composite: exclude;
            pointer-events: none;
            z-index: 2;
            background: radial-gradient(
                80px circle at var(--rx, -9999px) var(--ry, -9999px),
                rgba(var(--reveal-hi), 0.95),
                rgba(var(--reveal-mid), 0.45) 45%,
                transparent 70%
            );
            opacity: 0;
            transition: opacity var(--transition-fast) ease;
        }

        body.is-desktop .floating-btn::before {
            opacity: 1;
        }

        /* ==================== é®ç½© ==================== */
        .menu-mask {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(2px);
            -webkit-backdrop-filter: blur(2px);
            z-index: var(--z-mask);
            display: none;
            transition: opacity var(--transition-base) ease;
        }

        .menu-mask.active {
            display: block;
        }

        /* ==================== ä¾§è¾¹èœå• ==================== */
        .side-menu-wrapper {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 250px;
            height: 400px;
            max-width: calc(100vw - 60px);
            border-radius: var(--border-radius-lg);
            z-index: var(--z-menu);
            display: none;
            pointer-events: none;
        }

        .side-menu-wrapper.active {
            display: block;
            animation: menuAppear var(--transition-base) cubic-bezier(0.68, -0.55, 0.27, 1.55);
        }

        @keyframes menuAppear {
            0% {
                transform: scale(0.1);
                opacity: 0;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        /* èœå•wrapperå…‰æ•ˆ */
        .side-menu-wrapper::before {
            content: '';
            position: absolute;
            inset: -1px;
            padding: 1px;
            border-radius: inherit;
            -webkit-mask: linear-gradient(#fff 0 0) content-box, 
                         linear-gradient(#fff 0 0);
            -webkit-mask-composite: xor;
            mask-composite: exclude;
            pointer-events: none;
            z-index: 2;
            background: radial-gradient(
                150px circle at var(--rx, -9999px) var(--ry, -9999px),
                rgba(var(--reveal-hi), 0.95),
                rgba(var(--reveal-mid), 0.45) 45%,
                transparent 70%
            );
            opacity: 0;
        }

        body.is-desktop .side-menu-wrapper::before {
            opacity: 1;
        }

        .side-menu {
            position: relative;
            width: 100%;
            height: 100%;
            border-radius: var(--border-radius-lg);
            display: none;
            flex-direction: row;
            overflow: hidden;
            background: rgba(18, 18, 18, 0.6);
            backdrop-filter: blur(24px) saturate(180%);
            -webkit-backdrop-filter: blur(24px) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.18);
            pointer-events: auto;
            transition: background var(--transition-slow) ease, 
                        border-color var(--transition-slow) ease;
        }

        body.light-mode .side-menu {
            background: rgba(255, 255, 255, 0.6);
            border-color: rgba(0, 0, 0, 0.12);
        }

        body.is-desktop .side-menu {
            border: none;
        }

        .side-menu.active {
            display: flex;
        }

        /* èœå•å·¦ä¾§ï¼šç« èŠ‚åˆ—è¡¨ */
        .menu-left {
            position: relative;
            width: 200px;
            padding: 20px;
            overflow-y: auto;
            scrollbar-width: none;
            background: transparent;
        }

        .menu-left::-webkit-scrollbar {
            display: none;
        }

        /* ç« èŠ‚é¡¹ */
        .chapter-item {
            padding: 10px 0;
            cursor: pointer;
            color: rgba(255, 255, 255, 0.7);
            transition: color var(--transition-fast), 
                        padding-left var(--transition-fast);
            position: relative;
        }

        .chapter-item::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 8px;
            right: 8px;
            height: 1px;
            background: rgba(255, 255, 255, 0.3);
            transition: opacity var(--transition-base);
        }

        body.light-mode .chapter-item::after {
            background: rgba(0, 0, 0, 0.3);
        }

        body.is-desktop .chapter-item::after {
            opacity: 0;
        }

        .chapter-item:last-child::after {
            display: none;
        }

        .chapter-item.h1-item {
            padding-left: 0;
        }

        .chapter-item.h2-item {
            padding-left: 14px;
            color: rgba(255, 255, 255, 0.45);
            font-size: 0.9em;
        }

        .chapter-item.h3-item {
            padding-left: 28px;
            color: rgba(255, 255, 255, 0.3);
            font-size: 0.85em;
        }

        body.light-mode .chapter-item {
            color: rgba(0, 0, 0, 0.7);
        }

        body.light-mode .chapter-item.h2-item {
            color: rgba(0, 0, 0, 0.45);
        }

        body.light-mode .chapter-item.h3-item {
            color: rgba(0, 0, 0, 0.3);
        }

        body.is-desktop .chapter-item:hover {
            color: #f00;
        }

        body.is-desktop .chapter-item.h1-item:hover {
            padding-left: 5px;
        }

        body.is-desktop .chapter-item.h2-item:hover {
            padding-left: 19px;
        }

        body.is-desktop .chapter-item.h3-item:hover {
            padding-left: 33px;
        }

        .chapter-item.current {
            color: red !important;
        }

        .chapter-item.hovered {
            color: red !important;
        }

        /* èœå•å³ä¾§ï¼šæŒ‰é’®åŒº */
        .menu-right {
            position: relative;
            width: 50px;
            height: 100%;
            display: flex;
            flex-direction: column;
            background: rgba(0, 0, 0, 0.2);
            border-left: 1px solid rgba(255, 255, 255, 0.15);
            transition: background var(--transition-slow) ease, 
                        border-color var(--transition-slow) ease;
        }

        body.light-mode .menu-right {
            background: rgba(0, 0, 0, 0.05);
            border-left-color: rgba(0, 0, 0, 0.1);
        }

        body.is-desktop .menu-right,
        body.is-desktop.light-mode .menu-right {
            border-left-color: transparent;
        }

        /* å³ä¾§æŒ‰é’®åŒºå…‰æ•ˆ */
        .menu-right::before {
            content: '';
            position: absolute;
            inset: -1px;
            padding: 1px;
            border-radius: 0 var(--border-radius-lg) var(--border-radius-lg) 0;
            -webkit-mask: linear-gradient(#fff 0 0) content-box, 
                         linear-gradient(#fff 0 0);
            -webkit-mask-composite: xor;
            mask-composite: exclude;
            pointer-events: none;
            z-index: 2;
            background: radial-gradient(
                130px circle at var(--rx, -9999px) var(--ry, -9999px),
                rgba(var(--reveal-hi), 0.7),
                rgba(var(--reveal-mid), 0.3) 45%,
                transparent 70%
            );
            opacity: 0;
        }

        body.is-desktop .menu-right::before {
            opacity: 1;
        }

        .menu-buttons {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            padding: 20px 0;
            width: 100%;
        }

        .menu-btn {
            color: rgba(255, 255, 255, 0.75);
            background: none;
            border: none;
            cursor: pointer;
            transition: all var(--transition-fast);
            font-size: 20px;
            width: 50px;
            height: 47px;
            text-align: center;
            border-radius: 0;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        body.light-mode .menu-btn {
            color: rgba(0, 0, 0, 0.6);
        }

        body.is-desktop .menu-btn:hover {
            color: #f00;
            background-color: rgba(255, 0, 0, 0.1);
        }

        .close-btn {
            position: relative;
            height: 50px;
            background: rgba(0, 0, 0, 0.15);
            color: rgba(255, 255, 255, 0.6);
            border: none;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            cursor: pointer;
            font-size: 16px;
            transition: background var(--transition-fast), 
                        color var(--transition-fast), 
                        border-color var(--transition-fast);
            width: 100%;
        }

        body.light-mode .close-btn {
            background: rgba(0, 0, 0, 0.04);
            color: rgba(0, 0, 0, 0.5);
            border-top-color: rgba(0, 0, 0, 0.08);
        }

        body.is-desktop .close-btn {
            border-top: none;
            background: transparent;
        }

        body.is-desktop.light-mode .close-btn {
            border-top: none;
        }

        body.is-desktop .close-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: radial-gradient(
                130px circle at var(--rx, -9999px) var(--ry, -9999px),
                rgba(var(--reveal-hi), 0.95),
                rgba(var(--reveal-mid), 0.4) 45%,
                transparent 70%
            );
            pointer-events: none;
            z-index: 3;
        }

        body.is-desktop .close-btn:hover {
            color: #f00;
            background-color: rgba(255, 0, 0, 0.08);
        }

        /* Canvas å åŠ å±‚ */
        #menuRevealCanvas {
            position: fixed;
            pointer-events: none;
            z-index: var(--z-canvas);
            opacity: 0;
            transition: opacity var(--transition-fast);
        }

        #menuRevealCanvas.active {
            opacity: 1;
        }

        /* å·¥å…·ç±» */
        .no-select {
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }

        /* å“åº”å¼è°ƒæ•´ */
        @media (max-width: 768px) {
            .title {
                font-size: 2rem;
            }
            
            .side-menu-wrapper {
                width: calc(100vw - 40px);
                right: 20px;
            }
        }
    </style>
</head>

<body class="dark-mode no-select">
    <div class="header">
        <h1 class="title">SB</h1>
        <p class="summary">æš‚æ— ç®€ä»‹</p>
        <div class="date">2026-01-31</div>
        <div class="tags">
            <span class="tag">special</span>
        </div>
    </div>

    <div class="content">
        
    </div>

    <div class="comments"></div>

    <button class="floating-btn" id="menuToggle">â˜°</button>

    <div class="menu-mask" id="menuMask"></div>

    <div class="side-menu-wrapper" id="sideMenuWrapper">
        <div class="side-menu" id="sideMenu">
            <div class="menu-left" id="chapterList"></div>
            <div class="menu-right" id="menuRightEl">
                <div class="menu-buttons">
                    <button class="menu-btn" id="toBottomBtn">â–¼</button>
                    <button class="menu-btn" id="middleBtn">â—</button>
                    <button class="menu-btn" id="toTopBtn">â–²</button>
                </div>
                <button class="close-btn" id="closeBtn">â•³</button>
            </div>
        </div>
    </div>

    <canvas id="menuRevealCanvas"></canvas>

    <script>
        // ==================== å·¥å…·å‡½æ•°æ¨¡å— ====================
        const Utils = {
            /**
             * åˆ›å»ºé˜²æŠ–å‡½æ•°
             */
            createDebounce(fn, delay) {
                let timer = null;
                return {
                    call(...args) {
                        clearTimeout(timer);
                        timer = setTimeout(() => { timer = null; fn(...args); }, delay);
                    },
                    cancel() {
                        clearTimeout(timer);
                        timer = null;
                    },
                    get pending() {
                        return timer !== null;
                    }
                };
            },

            /**
             * åŸºäº Promise çš„å¹³æ»‘æ»šåŠ¨å®Œæˆæ£€æµ‹
             */
            smoothScrollPromise(scrollFn, getPosition, timeout = 1000) {
                return new Promise(resolve => {
                    scrollFn();
                    let lastPos = getPosition();
                    let stable = 0;
                    let started = false;
                    const t0 = performance.now();

                    const check = () => {
                        const now = performance.now();
                        const pos = getPosition();
                        if (pos !== lastPos) {
                            started = true;
                            stable = 0;
                            lastPos = pos;
                        } else {
                            if (started) {
                                if (++stable >= 3) {
                                    resolve();
                                    return;
                                }
                            } else if (now - t0 > 300) {
                                resolve();
                                return;
                            }
                        }
                        if (now - t0 > timeout) {
                            resolve();
                            return;
                        }
                        requestAnimationFrame(check);
                    };
                    requestAnimationFrame(check);
                });
            },

            /**
             * ç‚¹åˆ°çŸ©å½¢çš„è·ç¦»
             */
            distToRect(mouseX, mouseY, rect) {
                const dx = Math.max(rect.left - mouseX, 0, mouseX - rect.right);
                const dy = Math.max(rect.top - mouseY, 0, mouseY - rect.bottom);
                return Math.sqrt(dx * dx + dy * dy);
            },

            /**
             * ç‚¹åˆ°çŸ©å½¢é¡¶è¾¹çš„è·ç¦»
             */
            distToTopEdge(mouseX, mouseY, rect) {
                const dx = Math.max(rect.left - mouseX, 0, mouseX - rect.right);
                const dy = Math.abs(mouseY - rect.top);
                return Math.sqrt(dx * dx + dy * dy);
            },

            /**
             * æ›´æ–°å•ä¸ªå…ƒç´ çš„ Reveal å˜é‡
             */
            updateRevealVar(el, mouseX, mouseY, range, distFn = Utils.distToRect) {
                if (!el) return;
                const r = el.getBoundingClientRect();
                const dist = distFn(mouseX, mouseY, r);
                if (dist <= range) {
                    el.style.setProperty('--rx', (mouseX - r.left) + 'px');
                    el.style.setProperty('--ry', (mouseY - r.top) + 'px');
                } else {
                    el.style.setProperty('--rx', '-9999px');
                    el.style.setProperty('--ry', '-9999px');
                }
            },

            /**
             * æ¸…é™¤å…ƒç´ çš„ Reveal å˜é‡
             */
            clearRevealVar(el) {
                if (!el) return;
                el.style.setProperty('--rx', '-9999px');
                el.style.setProperty('--ry', '-9999px');
            }
        };

        // ==================== äº‹ä»¶ç®¡ç†å™¨ ====================
        class EventManager {
            constructor() {
                this.handlers = [];
            }

            add(target, event, handler, options = {}) {
                target.addEventListener(event, handler, options);
                this.handlers.push({ target, event, handler, options });
            }

            remove(target, event, handler) {
                target.removeEventListener(event, handler);
                this.handlers = this.handlers.filter(
                    h => !(h.target === target && h.event === event && h.handler === handler)
                );
            }

            destroy() {
                this.handlers.forEach(({ target, event, handler, options }) => {
                    target.removeEventListener(event, handler, options);
                });
                this.handlers = [];
            }
        }

        // ==================== çŠ¶æ€ç®¡ç†å™¨ ====================
        class StateManager {
            constructor(initialState = {}) {
                this.state = { ...initialState };
                this.listeners = new Set();
            }

            get(key) {
                return this.state[key];
            }

            set(key, value) {
                const oldValue = this.state[key];
                this.state[key] = value;
                this.notify(key, value, oldValue);
            }

            update(updates) {
                Object.assign(this.state, updates);
                this.notify();
            }

            subscribe(listener) {
                this.listeners.add(listener);
                return () => this.listeners.delete(listener);
            }

            notify(key, value, oldValue) {
                this.listeners.forEach(listener => {
                    try {
                        listener(this.state, { key, value, oldValue });
                    } catch (e) {
                        console.error('Listener error:', e);
                    }
                });
            }
        }

        // ==================== é˜²æŠ–ç®¡ç†å™¨ ====================
        class DebounceManager {
            constructor() {
                this.debounces = new Map();
            }

            register(name, fn, delay) {
                this.debounces.set(name, Utils.createDebounce(fn, delay));
            }

            call(name, ...args) {
                const debounce = this.debounces.get(name);
                if (debounce) debounce.call(...args);
            }

            cancel(name) {
                const debounce = this.debounces.get(name);
                if (debounce) debounce.cancel();
            }

            cancelAll() {
                this.debounces.forEach(debounce => debounce.cancel());
            }
        }

        // ==================== ä¸»é¢˜ç®¡ç†å™¨ ====================
        class ThemeManager {
            constructor() {
                this.applyTheme();
            }

            applyTheme() {
                const savedTheme = localStorage.getItem('theme');
                const configTheme = "dark";
                const mode = savedTheme || configTheme;
                document.body.classList.toggle('light-mode', mode === 'light');
                document.body.classList.toggle('dark-mode', mode !== 'light');
                
                // æ›´æ–°æµ®åŠ¨æŒ‰é’®é¢œè‰²
                const menuToggle = document.getElementById('menuToggle');
                if (menuToggle) {
                    menuToggle.style.color = mode === 'light' ? '#000' : '#fff';
                }
            }

            toggleTheme() {
                const isLight = document.body.classList.contains('light-mode');
                const newMode = isLight ? 'dark' : 'light';
                localStorage.setItem('theme', newMode);
                this.applyTheme();
            }
        }

        // ==================== ç« èŠ‚é«˜äº®å™¨ ====================
        class ChapterHighlighter {
            constructor(options) {
                this.contentEl = options.contentEl;
                this.chapterListEl = options.chapterListEl;
                this.isDesktop = options.isDesktop;
                this.state = options.state;
                this.debounces = new DebounceManager();
                
                this.allHeadings = [];
                this.onItemClick = options.onItemClick;

                // æ³¨å†Œé˜²æŠ–
                this.debounces.register('hoverScroll', this.onHoverScrollDebounced.bind(this), 1500);
                this.debounces.register('menuScroll', this.onMenuScrollDebounced.bind(this), 400);
                this.debounces.register('menuSync', this.onMenuSyncDebounced.bind(this), 150);
            }

            init() {
                this.extractHeadings();
                this.buildChapterList();
                this.bindEvents();
            }

            extractHeadings() {
                this.allHeadings = Array.from(this.contentEl.querySelectorAll('h1, h2, h3'))
                    .filter(h => h.textContent.trim() !== '');
                this.allHeadings.forEach((el, index) => {
                    el.id = `heading-${index}`;
                });
            }

            buildChapterList() {
                const classMap = { 1: 'h1-item', 2: 'h2-item', 3: 'h3-item' };
                
                this.allHeadings.forEach(heading => {
                    const listItem = document.createElement('div');
                    const level = parseInt(heading.tagName[1]);
                    listItem.className = `chapter-item ${classMap[level] || 'h1-item'}`;
                    listItem.textContent = heading.textContent;
                    listItem.dataset.id = heading.id;

                    listItem.addEventListener('click', (e) => {
                        e.stopPropagation();
                        heading.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        this.onItemClick?.();
                    });

                    if (this.isDesktop) {
                        listItem.addEventListener('pointerenter', (e) => {
                            if (e.pointerType !== 'mouse') return;
                            this.onItemPointerEnter(listItem);
                        });
                        listItem.addEventListener('pointerleave', (e) => {
                            if (e.pointerType !== 'mouse') return;
                            this.onItemPointerLeave();
                        });
                    }

                    this.chapterListEl.appendChild(listItem);
                });

                if (this.allHeadings.length > 0) {
                    this.state.set('currentId', this.allHeadings[0].id);
                    this.applyScrollState(this.state.get('currentId'));
                }
            }

            bindEvents() {
                window.addEventListener('scroll', this.updateActiveHeading.bind(this), { passive: true });

                this.chapterListEl.addEventListener('wheel', () => {
                    if (!this.state.get('isWheelScrolling')) {
                        this.state.set('isWheelScrolling', true);
                        if (this.state.get('activeState') === 'hover') {
                            this.debounces.cancel('hoverScroll');
                            this.state.set('hoveredItem', null);
                            this.state.set('activeState', 'scroll');
                            this.setHighlight(this.state.get('currentId'));
                        }
                    }
                }, { passive: true });

                this.chapterListEl.addEventListener('scroll', () => {
                    if (this.state.get('programmaticScrollCount') > 0) return;
                    if (this.state.get('activeState') === 'hover') return;
                    
                    this.state.set('isMenuScrolling', true);
                    this.state.set('activeState', 'menu');
                    
                    const realtimeId = this.getCenteredItemId();
                    if (realtimeId) this.setHighlight(realtimeId);
                    
                    this.debounces.call('menuScroll');
                }, { passive: true });

                const onTouchEnd = () => {
                    if (this.state.get('hoveredItem')) this.state.set('hoveredItem', null);
                    if (this.state.get('activeState') === 'menu') this.debounces.call('menuScroll');
                };

                this.chapterListEl.addEventListener('touchend', onTouchEnd);
                this.chapterListEl.addEventListener('touchcancel', onTouchEnd);

                if (this.isDesktop) {
                    this.chapterListEl.addEventListener('pointerleave', (e) => {
                        if (e.pointerType !== 'mouse') return;
                        if (this.state.get('isWheelScrolling') || this.state.get('isHoverScrolling')) return;
                        if (this.state.get('activeState') === 'hover') this.onItemPointerLeave();
                    });
                }
            }

            setHighlight(id) {
                this.chapterListEl.querySelectorAll('.chapter-item.current, .chapter-item.hovered')
                    .forEach(i => i.classList.remove('current', 'hovered'));
                
                if (!id) return;
                
                const item = this.chapterListEl.querySelector(`.chapter-item[data-id="${id}"]`);
                if (item) {
                    item.classList.add(this.state.get('activeState') === 'scroll' ? 'current' : 'hovered');
                }
            }

            scrollMenuToItem(id, behavior = 'smooth') {
                const item = this.chapterListEl.querySelector(`.chapter-item[data-id="${id}"]`);
                if (!item) return Promise.resolve();
                
                const target = item.offsetTop - (this.chapterListEl.clientHeight - item.offsetHeight) / 2;
                if (this.chapterListEl.scrollHeight <= this.chapterListEl.clientHeight) return Promise.resolve();

                this.state.set('programmaticScrollCount', this.state.get('programmaticScrollCount') + 1);
                
                return Utils.smoothScrollPromise(
                    () => this.chapterListEl.scrollTo({ top: Math.max(0, target), behavior }),
                    () => this.chapterListEl.scrollTop
                ).finally(() => {
                    this.state.set('programmaticScrollCount', this.state.get('programmaticScrollCount') - 1);
                });
            }

            getCenteredItemId() {
                const items = this.chapterListEl.querySelectorAll('.chapter-item');
                const containerR = this.chapterListEl.getBoundingClientRect();
                const centerY = containerR.top + containerR.height / 2;
                
                let best = null, bestDist = Infinity;
                items.forEach(item => {
                    const r = item.getBoundingClientRect();
                    const dist = Math.abs(r.top + r.height / 2 - centerY);
                    if (dist < bestDist) {
                        bestDist = dist;
                        best = item;
                    }
                });
                
                return best ? best.dataset.id : null;
            }

            onMenuSyncDebounced(id) {
                if (this.state.get('activeState') === 'scroll' && !this.state.get('isMenuScrolling')) {
                    this.scrollMenuToItem(id);
                }
            }

            applyScrollState(id) {
                if (this.state.get('activeState') === 'hover' || this.state.get('activeState') === 'menu') return;
                
                this.state.set('activeState', 'scroll');
                this.state.set('currentId', id);
                this.setHighlight(id);
                this.debounces.call('menuSync', id);
            }

            updateActiveHeading() {
                if (this.allHeadings.length === 0) return;
                if (this.state.get('menuDrivingArticleCount') > 0) return;
                if (this.state.get('isHoverScrolling')) return;

                const scrollY = window.scrollY;
                const offset = 80;
                let current = this.allHeadings[0];

                for (let i = 0; i < this.allHeadings.length; i++) {
                    const top = this.allHeadings[i].getBoundingClientRect().top + scrollY;
                    if (top <= scrollY + offset) current = this.allHeadings[i];
                    else break;
                }

                if (current.id !== this.state.get('currentId') || this.state.get('activeState') !== 'scroll') {
                    this.applyScrollState(current.id);
                }
            }

            getItemAtPointer() {
                const el = document.elementFromPoint(
                    this.state.get('lastMouseX'), 
                    this.state.get('lastMouseY')
                );
                return el ? el.closest('.chapter-item') : null;
            }

            resolvePointerAfterScroll(item) {
                const itemAtPointer = this.getItemAtPointer();
                
                if (itemAtPointer && itemAtPointer !== item) {
                    this.onItemPointerEnter(itemAtPointer);
                } else if (!itemAtPointer) {
                    this.state.set('hoveredItem', null);
                    this.state.set('activeState', 'scroll');
                    this.setHighlight(this.state.get('currentId'));
                } else {
                    this.debounces.call('hoverScroll', item);
                }
            }

            async onHoverScrollDebounced(item) {
                if (this.state.get('activeState') !== 'hover' || this.state.get('hoveredItem') !== item) return;
                
                this.setHighlight(item.dataset.id);
                
                this.state.set('isHoverScrolling', true);
                await this.scrollMenuToItem(item.dataset.id);
                this.state.set('isHoverScrolling', false);

                if (this.state.get('activeState') !== 'hover' || this.state.get('hoveredItem') !== item) return;

                const targetHeading = document.getElementById(item.dataset.id);
                if (targetHeading) {
                    this.state.set('isHoverScrolling', true);
                    this.state.set('menuDrivingArticleCount', this.state.get('menuDrivingArticleCount') + 1);
                    
                    try {
                        await Utils.smoothScrollPromise(
                            () => targetHeading.scrollIntoView({ behavior: 'smooth', block: 'start' }),
                            () => window.scrollY
                        );
                    } finally {
                        this.state.set('menuDrivingArticleCount', this.state.get('menuDrivingArticleCount') - 1);
                        
                        if (this.state.get('activeState') === 'hover' && this.state.get('hoveredItem') === item) {
                            this.state.set('currentId', item.dataset.id);
                        }
                        
                        this.state.set('isHoverScrolling', false);
                        
                        if (this.state.get('activeState') === 'hover' && this.state.get('hoveredItem') === item) {
                            this.resolvePointerAfterScroll(item);
                        }
                    }
                } else {
                    this.state.set('isHoverScrolling', false);
                    if (this.state.get('activeState') === 'hover' && this.state.get('hoveredItem') === item) {
                        this.resolvePointerAfterScroll(item);
                    }
                }
            }

            onItemPointerEnter(item) {
                if (this.state.get('isWheelScrolling') || this.state.get('isHoverScrolling')) return;
                
                this.state.set('hoveredItem', item);
                this.state.set('activeState', 'hover');
                this.setHighlight(item.dataset.id);
                this.debounces.call('hoverScroll', item);
            }

            onItemPointerLeave() {
                if (this.state.get('isWheelScrolling') || this.state.get('isHoverScrolling')) return;
                
                this.debounces.cancel('hoverScroll');
                this.state.set('hoveredItem', null);
                this.state.set('activeState', 'scroll');
                this.setHighlight(this.state.get('currentId'));
                this.scrollMenuToItem(this.state.get('currentId'));
            }

            async onMenuScrollDebounced() {
                this.state.set('isMenuScrolling', false);
                
                const centerId = this.getCenteredItemId();
                if (!centerId) {
                    this.state.set('isWheelScrolling', false);
                    return;
                }

                try {
                    await this.scrollMenuToItem(centerId);
                    
                    if (this.state.get('activeState') !== 'menu' || this.state.get('hoveredItem')) {
                        this.state.set('isWheelScrolling', false);
                        return;
                    }

                    this.state.set('currentId', centerId);
                    this.setHighlight(centerId);

                    const targetHeading = document.getElementById(centerId);
                    if (targetHeading) {
                        this.state.set('menuDrivingArticleCount', this.state.get('menuDrivingArticleCount') + 1);
                        
                        await Utils.smoothScrollPromise(
                            () => targetHeading.scrollIntoView({ behavior: 'smooth', block: 'start' }),
                            () => window.scrollY
                        );
                        
                        this.state.set('menuDrivingArticleCount', this.state.get('menuDrivingArticleCount') - 1);
                        this.state.set('isWheelScrolling', false);
                        
                        if (this.state.get('activeState') === 'menu' && !this.state.get('hoveredItem')) {
                            this.state.set('activeState', 'scroll');
                            this.setHighlight(this.state.get('currentId'));
                        }
                    } else {
                        this.state.set('isWheelScrolling', false);
                        this.state.set('activeState', 'scroll');
                        this.setHighlight(this.state.get('currentId'));
                    }
                } catch {
                    this.state.set('isWheelScrolling', false);
                }
            }

            syncToMenu() {
                if (this.state.get('currentId')) {
                    this.scrollMenuToItem(this.state.get('currentId'), 'instant');
                }
            }

            cancelHover() {
                this.debounces.cancel('hoverScroll');
                this.state.set('hoveredItem', null);
                
                if (this.state.get('activeState') === 'hover') {
                    this.state.set('activeState', 'scroll');
                    this.setHighlight(this.state.get('currentId'));
                }
            }

            destroy() {
                this.debounces.cancelAll();
                window.removeEventListener('scroll', this.updateActiveHeading);
            }
        }

        // ==================== Reveal å…‰æ•ˆ ====================
        class RevealEffect {
            constructor(options) {
                this.canvasEl = options.canvasEl;
                this.ctx = this.canvasEl.getContext('2d');
                this.chapterListEl = options.chapterListEl;
                this.menuWrapperEl = options.menuWrapperEl;
                this.targets = options.targets;
                this.state = options.state;
                
                this.cachedMenuRect = null;
                this.cachedItemRects = null;
                this.rafPending = false;
                
                this.eventManager = new EventManager();
                this.debounces = new DebounceManager();
                
                this.init();
            }

            init() {
                this.debounces.register('redrawAfterScroll', () => {
                    if (this.isMenuActive()) {
                        this.resizeCanvas();
                        this.drawDividerGlow(this.state.get('lastMouseX'), this.state.get('lastMouseY'));
                    }
                }, 150);

                this.bindEvents();
            }

            isMenuActive() {
                return this.menuWrapperEl.classList.contains('active');
            }

            bindEvents() {
                this.eventManager.add(this.chapterListEl, 'scroll', () => {
                    if (this.isMenuActive()) {
                        this.cachedItemRects = null;
                        requestAnimationFrame(() => {
                            this.resizeCanvas();
                            this.ctx.clearRect(0, 0, this.canvasEl.width, this.canvasEl.height);
                        });
                        this.debounces.call('redrawAfterScroll');
                    }
                }, { passive: true });

                const handleMove = (e) => {
                    if (e.pointerType && e.pointerType !== 'mouse') return;
                    
                    this.state.set('lastMouseX', e.clientX);
                    this.state.set('lastMouseY', e.clientY);
                    
                    const menuActive = this.isMenuActive();

                    // æ›´æ–° CSS å˜é‡
                    this.targets.forEach(({ el, range, alwaysOn, distFn }) => {
                        if (!alwaysOn && !menuActive) {
                            Utils.clearRevealVar(el);
                            return;
                        }
                        Utils.updateRevealVar(el, e.clientX, e.clientY, range, distFn);
                    });

                    // Canvas ç»˜åˆ¶
                    if (menuActive) {
                        if (!this.cachedMenuRect) this.resizeCanvas();
                        this.canvasEl.classList.add('active');
                        
                        if (!this.rafPending) {
                            this.rafPending = true;
                            requestAnimationFrame(() => {
                                this.rafPending = false;
                                if (this.isMenuActive()) {
                                    this.drawDividerGlow(this.state.get('lastMouseX'), this.state.get('lastMouseY'));
                                }
                            });
                        }
                    }
                };

                this.eventManager.add(document, 'pointermove', handleMove);
                this.eventManager.add(document, 'pointerup', handleMove);
                this.eventManager.add(document, 'pointerleave', this.clearAllReveal.bind(this));
                this.eventManager.add(window, 'blur', this.clearAllReveal.bind(this));
                this.eventManager.add(window, 'resize', () => {
                    this.cachedMenuRect = null;
                    this.cachedItemRects = null;
                    this.resizeCanvas();
                });
            }

            buildItemRectCache(menuRect) {
                this.cachedItemRects = Array.from(
                    this.chapterListEl.querySelectorAll('.chapter-item:not(:last-child)')
                ).map(item => {
                    const r = item.getBoundingClientRect();
                    return {
                        lineY: r.bottom - menuRect.top,
                        lineLeft: r.left - menuRect.left + 8,
                        lineRight: r.right - menuRect.left - 8,
                    };
                });
            }

            getColorCache() {
                const style = getComputedStyle(document.body);
                return {
                    hi: style.getPropertyValue('--reveal-hi').trim(),
                    mid: style.getPropertyValue('--reveal-mid').trim()
                };
            }

            resizeCanvas() {
                if (!this.isMenuActive()) return;
                
                const r = this.chapterListEl.getBoundingClientRect();
                this.canvasEl.width = r.width;
                this.canvasEl.height = r.height;
                this.canvasEl.style.left = r.left + 'px';
                this.canvasEl.style.top = r.top + 'px';
                this.cachedMenuRect = r;
                this.cachedItemRects = null;
            }

            drawDividerGlow(mouseX, mouseY) {
                this.ctx.clearRect(0, 0, this.canvasEl.width, this.canvasEl.height);
                if (!this.isMenuActive()) return;

                const colors = this.getColorCache();
                const menuRect = this.chapterListEl.getBoundingClientRect();

                // æ ¡éªŒå¹¶ä¿®æ­£ canvas å°ºå¯¸
                if (this.canvasEl.width !== Math.round(menuRect.width) ||
                    this.canvasEl.height !== Math.round(menuRect.height) ||
                    parseFloat(this.canvasEl.style.left) !== menuRect.left ||
                    parseFloat(this.canvasEl.style.top) !== menuRect.top) {
                    
                    this.canvasEl.width = menuRect.width;
                    this.canvasEl.height = menuRect.height;
                    this.canvasEl.style.left = menuRect.left + 'px';
                    this.canvasEl.style.top = menuRect.top + 'px';
                    this.cachedMenuRect = menuRect;
                    this.cachedItemRects = null;
                }

                const radius = 80;
                if (Utils.distToRect(mouseX, mouseY, menuRect) > radius) return;

                if (!this.cachedItemRects) this.buildItemRectCache(menuRect);

                this.cachedItemRects.forEach(({ lineY, lineLeft, lineRight }) => {
                    if (lineY < 0 || lineY > this.canvasEl.height) return;

                    const nearestX = Math.max(lineLeft, Math.min(mouseX - menuRect.left, lineRight));
                    const dist = Math.hypot(
                        mouseX - menuRect.left - nearestX,
                        mouseY - menuRect.top - lineY
                    );

                    if (dist > radius) return;

                    const intensity = 1 - dist / radius;
                    const gx = mouseX - menuRect.left;
                    const grad = this.ctx.createRadialGradient(gx, lineY, 0, gx, lineY, radius);
                    
                    grad.addColorStop(0, `rgba(${colors.hi},${intensity})`);
                    grad.addColorStop(0.4, `rgba(${colors.mid},${0.65 * intensity})`);
                    grad.addColorStop(1, `rgba(${colors.mid},0)`);

                    this.ctx.beginPath();
                    this.ctx.moveTo(lineLeft, lineY);
                    this.ctx.lineTo(lineRight, lineY);
                    this.ctx.lineWidth = 1;
                    this.ctx.strokeStyle = grad;
                    this.ctx.stroke();
                });
            }

            clearAllReveal() {
                this.targets.forEach(({ el }) => Utils.clearRevealVar(el));
                this.ctx.clearRect(0, 0, this.canvasEl.width, this.canvasEl.height);
                this.canvasEl.classList.remove('active');
                this.rafPending = false;
            }

            destroy() {
                this.eventManager.destroy();
                this.debounces.cancelAll();
            }
        }

        // ==================== èœå•æ§åˆ¶å™¨ ====================
        class MenuController {
            constructor(options) {
                this.menuToggle = options.menuToggle;
                this.sideMenuWrapper = options.sideMenuWrapper;
                this.sideMenu = options.sideMenu;
                this.menuMask = options.menuMask;
                this.closeBtn = options.closeBtn;
                this.toBottomBtn = options.toBottomBtn;
                this.middleBtn = options.middleBtn;
                this.toTopBtn = options.toTopBtn;
                
                this.highlighter = options.highlighter;
                this.reveal = options.reveal;
                this.isDesktop = options.isDesktop;
                
                this.eventManager = new EventManager();
            }

            init() {
                this.bindEvents();
            }

            bindEvents() {
                this.eventManager.add(this.menuToggle, 'click', (e) => {
                    e.stopPropagation();
                    this.open();
                });

                this.eventManager.add(this.closeBtn, 'click', (e) => {
                    e.stopPropagation();
                    this.close();
                });

                this.eventManager.add(this.menuMask, 'click', (e) => {
                    e.stopPropagation();
                    this.close();
                });

                this.eventManager.add(this.sideMenu, 'click', (e) => e.stopPropagation());

                this.eventManager.add(this.toBottomBtn, 'click', (e) => {
                    e.stopPropagation();
                    window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
                    this.close();
                });

                this.eventManager.add(this.middleBtn, 'click', (e) => {
                    e.stopPropagation();
                    const middle = (document.documentElement.scrollHeight - window.innerHeight) / 2;
                    window.scrollTo({ top: middle, behavior: 'smooth' });
                    this.close();
                });

                this.eventManager.add(this.toTopBtn, 'click', (e) => {
                    e.stopPropagation();
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                    this.close();
                });
            }

            open() {
                this.sideMenuWrapper.classList.add('active');
                this.sideMenu.classList.add('active');
                this.menuMask.classList.add('active');
                this.menuToggle.style.display = 'none';
                
                this.highlighter.syncToMenu();
                
                if (this.isDesktop && this.reveal) {
                    this.reveal.resizeCanvas();
                }
            }

            close() {
                this.sideMenuWrapper.classList.remove('active');
                this.sideMenu.classList.remove('active');
                this.menuMask.classList.remove('active');
                this.menuToggle.style.display = 'flex';
                
                if (this.isDesktop && this.reveal) {
                    this.reveal.clearAllReveal();
                }
                
                this.highlighter.cancelHover();
            }

            destroy() {
                this.eventManager.destroy();
            }
        }

        // ==================== æ»šåŠ¨è¿›åº¦æŒ‡ç¤ºå™¨ ====================
        class ProgressIndicator {
            constructor(menuToggle) {
                this.menuToggle = menuToggle;
                this.styleEl = document.createElement('style');
                document.head.appendChild(this.styleEl);
                
                this.update = this.update.bind(this);
                window.addEventListener('scroll', this.update, { passive: true });
                this.update();
            }

            update() {
                const scrollHeight = document.documentElement.scrollHeight - window.innerHeight;
                const scrollPercent = scrollHeight > 0 ? Math.min(window.scrollY / scrollHeight, 1) : 0;
                const redValue = Math.floor(scrollPercent * 255);
                
                this.menuToggle.style.backgroundColor = `rgb(${redValue}, 0, 0)`;
                this.menuToggle.style.boxShadow = 'none';

                const isLight = document.body.classList.contains('light-mode');
                const t = 1 - scrollPercent;
                
                let hiColor, midColor;
                
                if (isLight) {
                    const r = Math.round(20 + 60 * t);
                    const g = Math.round(20 + 60 * t);
                    const b = Math.round(60 + 120 * t);
                    const r2 = Math.round(15 + 45 * t);
                    const b2 = Math.round(50 + 110 * t);
                    hiColor = `${r}, ${g}, ${b}`;
                    midColor = `${r2}, ${g}, ${b2}`;
                } else {
                    const gb = Math.round(255 * (1 - t));
                    const midR = Math.round(180 * t + 255 * (1 - t));
                    const midGB = Math.round(gb * 0.5);
                    hiColor = `255, ${gb}, ${gb}`;
                    midColor = `${midR}, ${midGB}, ${midGB}`;
                }

                this.styleEl.textContent = `
                    .floating-btn::before {
                        background: radial-gradient(
                            80px circle at var(--rx, -9999px) var(--ry, -9999px),
                            rgba(${hiColor}, 0.95),
                            rgba(${midColor}, 0.45) 45%,
                            transparent 70%
                        );
                    }
                `;
            }

            destroy() {
                window.removeEventListener('scroll', this.update);
                this.styleEl.remove();
            }
        }

        // ==================== ä¸»åº”ç”¨åˆå§‹åŒ– ====================
        class App {
            constructor() {
                this.elements = this.getElements();
                this.isDesktop = window.matchMedia('(hover: hover) and (pointer: fine)').matches;
                
                if (this.isDesktop) {
                    document.body.classList.add('is-desktop');
                }

                this.state = new StateManager({
                    currentId: null,
                    hoveredItem: null,
                    activeState: 'scroll',
                    isMenuScrolling: false,
                    isWheelScrolling: false,
                    isHoverScrolling: false,
                    programmaticScrollCount: 0,
                    menuDrivingArticleCount: 0,
                    lastMouseX: -9999,
                    lastMouseY: -9999
                });

                this.themeManager = new ThemeManager();
                
                this.highlighter = new ChapterHighlighter({
                    contentEl: document.querySelector('.content'),
                    chapterListEl: this.elements.chapterList,
                    isDesktop: this.isDesktop,
                    state: this.state,
                    onItemClick: () => this.menuController?.close()
                });

                if (this.isDesktop) {
                    this.reveal = new RevealEffect({
                        canvasEl: this.elements.menuRevealCanvas,
                        chapterListEl: this.elements.chapterList,
                        menuWrapperEl: this.elements.sideMenuWrapper,
                        targets: [
                            { el: this.elements.menuToggle, range: 60, alwaysOn: true, distFn: Utils.distToRect },
                            { el: this.elements.sideMenuWrapper, range: 80, alwaysOn: false, distFn: Utils.distToRect },
                            { el: this.elements.menuRightEl, range: 80, alwaysOn: false, distFn: Utils.distToRect },
                            { el: this.elements.closeBtn, range: 80, alwaysOn: false, distFn: Utils.distToTopEdge }
                        ],
                        state: this.state
                    });
                }

                this.menuController = new MenuController({
                    menuToggle: this.elements.menuToggle,
                    sideMenuWrapper: this.elements.sideMenuWrapper,
                    sideMenu: this.elements.sideMenu,
                    menuMask: this.elements.menuMask,
                    closeBtn: this.elements.closeBtn,
                    toBottomBtn: this.elements.toBottomBtn,
                    middleBtn: this.elements.middleBtn,
                    toTopBtn: this.elements.toTopBtn,
                    highlighter: this.highlighter,
                    reveal: this.reveal,
                    isDesktop: this.isDesktop
                });

                this.progressIndicator = new ProgressIndicator(this.elements.menuToggle);
            }

            getElements() {
                return {
                    menuToggle: document.getElementById('menuToggle'),
                    sideMenuWrapper: document.getElementById('sideMenuWrapper'),
                    sideMenu: document.getElementById('sideMenu'),
                    menuMask: document.getElementById('menuMask'),
                    closeBtn: document.getElementById('closeBtn'),
                    toBottomBtn: document.getElementById('toBottomBtn'),
                    middleBtn: document.getElementById('middleBtn'),
                    toTopBtn: document.getElementById('toTopBtn'),
                    chapterList: document.getElementById('chapterList'),
                    menuRightEl: document.getElementById('menuRightEl'),
                    menuRevealCanvas: document.getElementById('menuRevealCanvas')
                };
            }

            init() {
                this.highlighter.init();
                this.menuController.init();
            }

            destroy() {
                this.highlighter.destroy();
                this.menuController.destroy();
                if (this.reveal) this.reveal.destroy();
                this.progressIndicator.destroy();
            }
        }

        // ==================== å¯åŠ¨åº”ç”¨ ====================
        document.addEventListener('DOMContentLoaded', () => {
            window.app = new App();
            window.app.init();
        });
    </script>
</body>

</html>